<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="description" content="该章节汇总了学习过的 Java 语言特性集合。以及理解语言特性的一些前置概念。">
<link rel="alternate"
      type="application/rss+xml"
      href="https://oahnukuw.github.io/feed.xml"
      title="RSS feed for https://oahnukuw.github.io/">
<title>§Java Features That I Learned</title>
<meta name="author" content="oahnukuw">
<meta name="referrer" content="no-referrer">
<meta content="width=device-width, initial-scale=1" name="viewport" />
<link href="static/style.css" rel="stylesheet" type="text/css" />
<link rel="icon" href="static/favicon.ico" type="image/x-icon"/>
<link rel="icon" type="image/png" sizes="32x32" href="static/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="static/favicon-16x16.png">
</head>
<body>
<div id="preamble" class="status"><!-- define useful svg icons -->
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="github" viewBox="0 0 16 16">
    <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z"/>
  </symbol>
  <symbol id="linkedin" viewBox="0 0 16 16">
    <path d="M0 1.146C0 .513.526 0 1.175 0h13.65C15.474 0 16 .513 16 1.146v13.708c0 .633-.526 1.146-1.175 1.146H1.175C.526 16 0 15.487 0 14.854V1.146zm4.943 12.248V6.169H2.542v7.225h2.401zm-1.2-8.212c.837 0 1.358-.554 1.358-1.248-.015-.709-.52-1.248-1.342-1.248-.822 0-1.359.54-1.359 1.248 0 .694.521 1.248 1.327 1.248h.016zm4.908 8.212V9.359c0-.216.016-.432.08-.586.173-.431.568-.878 1.232-.878.869 0 1.216.662 1.216 1.634v3.865h2.401V9.25c0-2.22-1.184-3.252-2.764-3.252-1.274 0-1.845.7-2.165 1.193v.025h-.016a5.54 5.54 0 0 1 .016-.025V6.169h-2.4c.03.678 0 7.225 0 7.225h2.4z"/>
  </symbol>
  <symbol id="rss-fill" viewBox="0 0 16 16">
    <path d="M2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2zm1.5 2.5c5.523 0 10 4.477 10 10a1 1 0 1 1-2 0 8 8 0 0 0-8-8 1 1 0 0 1 0-2zm0 4a6 6 0 0 1 6 6 1 1 0 1 1-2 0 4 4 0 0 0-4-4 1 1 0 0 1 0-2zm.5 7a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3z"/>
  </symbol>
</svg>

<div class="header">
  <!-- <img src="static/monkey.png"/> -->
  <a class="page-title" href="https://oahnukuw.github.io">@oahnukuw</a>
  <span class="menu-links">
    <a href="about.html">about</a> |
    <a href="projects.html">projects</a> |
    <a href="archive.html">archive</a> |
    <a href="feed.xml">
      <svg class="menu-icons"><use href="#rss-fill"/></svg>
    </a> |
  </span>
</div>
<hr class="preamble-sep" />
</div>
<div id="content">
<div class="post-date">06 Aug 2024</div><h1 class="post-title"><a href="https://oahnukuw.github.io/20240806T182547--java_features_that_i_learned.html">§Java Features That I Learned</a></h1>
<nav id="table-of-contents" role="doc-toc">
<h2> <a href="javascript:window.scrollTo(0,0)" style="color: black !important;" class="tooltip" title="Go to the top of the page">Ξ </a> </h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org754e5cf">1. programming.semantics</a></li>
<li><a href="#orgf4d0365">2. lang.java.class.life-circle</a>
<ul>
<li><a href="#org0ea31a2">2.1. 加载：查找字节码文件并载入内存</a></li>
<li><a href="#org0e8b5e0">2.2. 连接</a></li>
<li><a href="#org90f1b80">2.3. 初始化</a></li>
<li><a href="#orge94b733">2.4. 卸载</a></li>
<li><a href="#org3344549">2.5. 参见：https://pdai.tech/md/java/jvm/java-jvm-classload.html</a></li>
</ul>
</li>
<li><a href="#org8132509">3. lang.java.concept.object&#x2013;abstraction of code</a>
<ul>
<li><a href="#orgbb19382">3.1. equals-hashCode-override</a></li>
<li><a href="#org6eeacfe">3.2. 参见：</a></li>
</ul>
</li>
<li><a href="#org1f7768f">4. lang.java.concept.classpath&#x2013;url to locate class</a>
<ul>
<li><a href="#orga247941">4.1. 方法参数传递</a></li>
<li><a href="#orgcc8b54d">4.2. References</a></li>
</ul>
</li>
<li><a href="#org254fad8">5. lang.java.concept.object_oriented_programming&#x2013;code abstraction base on object</a>
<ul>
<li><a href="#org0d8c456">5.1. Encapsulation</a></li>
<li><a href="#org58b3fcb">5.2. Reference</a></li>
</ul>
</li>
<li><a href="#orgc36b931">6. lang.java.feat.inheritance&#x2013;Mechanism to reuse code (field-method)</a>
<ul>
<li><a href="#org32a0bc8">6.1. inheritance.method-call-priority</a></li>
</ul>
</li>
<li><a href="#orgc027445">7. lang.java.feat.polymorphism&#x2013;Mechanism-to-seperate-code</a>
<ul>
<li><a href="#org9fde269">7.1. 多态意味着面向抽象编程</a></li>
<li><a href="#org1b8e411">7.2. polymorphism.example</a></li>
</ul>
</li>
<li><a href="#org7d3987c">8. lang.java.feat.auto_boxing&#x2013;Box of basic data type</a></li>
<li><a href="#org2bdf07f">9. lang.java.feat.reflection&#x2013;Mechanism to manipulate class</a>
<ul>
<li><a href="#org03575bb">9.1. 获取「类」的 Class&lt;T&gt; 对象</a></li>
<li><a href="#orgb860f6e">9.2. 操作字段通过 Class&lt;T&gt; 中的 Field 相关方法</a></li>
<li><a href="#orgf431c89">9.3. 操作方法通过 Class&lt;T&gt; 中的 Method 相关方法</a></li>
</ul>
</li>
<li><a href="#org9221c00">10. lang.java.feat.access_level_modifiers&#x2013;Mechanism to restrict scope of access</a>
<ul>
<li><a href="#org1937ffb">10.1. Reference</a></li>
</ul>
</li>
<li><a href="#orgb1e4f6c">11. lang.java.feat.exception&#x2013;Mechanism to deal with error of code</a>
<ul>
<li><a href="#orgbe38206">11.1. lang.java.feat.exception.claim-to-catch</a></li>
<li><a href="#orgd17358f">11.2. lang.java.feat.exception.type</a></li>
<li><a href="#org643bd03">11.3. lang.java.feat.exception.throw-example</a></li>
</ul>
</li>
<li><a href="#org868300c">12. lang.java.feat.anonymous_class&#x2013;Mechanism to deliver interface to methods</a>
<ul>
<li><a href="#org79c980f">12.1. Definition</a></li>
<li><a href="#org3e5b81a">12.2. Access to protected method in other package</a></li>
<li><a href="#orgd9fd6a4">12.3. Use Cases</a></li>
<li><a href="#org4272b93">12.4. lang.java.feat.lambda simplifcation-lambda-expression</a></li>
<li><a href="#orgc080d59">12.5. reference</a></li>
</ul>
</li>
<li><a href="#org57b504d">13. lang.java.feat.nested_class&#x2013;Way to group class to make code neatter</a>
<ul>
<li><a href="#org416d3db">13.1. Why Use Nested Classes?</a></li>
</ul>
</li>
<li><a href="#org9ac8788">14. lang.java.feat.static_nested_class&#x2013;As the same as top-level class but nested</a></li>
<li><a href="#org1f16459">15. lang.java.feat.interface&#x2013;Define behavior of code but no implementation</a></li>
<li><a href="#org6aa7135">16. lang.java.feat.abstract_class&#x2013;Mechanism between Class and Interface</a>
<ul>
<li><a href="#org4bed151">16.1. abstract-template-pattern</a></li>
<li><a href="#org744f3ad">16.2. Reference</a></li>
</ul>
</li>
<li><a href="#orgb090c13">17. lang.java.feat.dynamic_proxy&#x2013;Mechanism to append feature to existed code</a></li>
<li><a href="#org90ba124">18. lang.java.feat.lambda&#x2013;Syntactic sugar of anonymous class</a>
<ul>
<li><a href="#org7da9abf">18.1. lang.java.feat.lambda.method-qoute</a></li>
<li><a href="#org8e1854f">18.2. Functional Interface</a></li>
</ul>
</li>
<li><a href="#org62a26e2">19. brochure.java.feat.optional&#x2013;Return-default-if-object-null</a></li>
<li><a href="#orgea5ea5c">20. lang.java.feat.stream.collectors</a>
<ul>
<li><a href="#orge126796">20.1. brochure</a></li>
</ul>
</li>
<li><a href="#org8adf261">21. Reference</a></li>
<li><a href="#orgcf3f5b8">22. Update</a></li>
</ul>
</div>
</nav>

<div id="outline-container-org754e5cf" class="outline-2">
<h2 id="org754e5cf"><span class="section-number-2">1.</span> programming.semantics</h2>
<div class="outline-text-2" id="text-1">
<blockquote>
<p>
Semantics in programming refers to the meaning or behavior associated with a piece of code. It encompasses how a programming construct behaves during execution, what it does, and how it interacts with other parts of the program. Semantics contrasts with syntax, which is the set of rules that define the structure and form of valid code.
</p>
</blockquote>

<p>
语义是理解程序的关键。语义指代代码在执行过程的行为，代码会做些什么，以及怎么做。
</p>

<p>
但理解程序的语义并不是一件简单的事情。在编程语言的角度，其基础是语法以及语言特性。
</p>

<p>
比如，一个 <a href="#org1f16459">lang.java.feat.interface</a> 关键字所蕴含的语义是非常丰富的。interface 的语义可以是一种「契约」（contract），体现的是实现该 interface 的 class 具备什么样的能力，「即能做什么」。另外，interface 还可以是实现多继承的机制，通过实现多个 interface，一个 class 可以具备不同类型的能力。除此之外，接口的多实现展现了多态。通过持有多态引用（polymorphic reference），可以获得具备多种实现的通用代码，即多态。
</p>

<p>
除了语言特性外，可能还需要具备软件设计的其他知识，比如设计模式，才能看懂蕴含设计模式的代码。
</p>
</div>
</div>

<div id="outline-container-orgf4d0365" class="outline-2">
<h2 id="orgf4d0365"><span class="section-number-2">2.</span> lang.java.class.life-circle</h2>
<div class="outline-text-2" id="text-2">
<p>
为了行文方便，后续简称 「Java 类」为「类」。
</p>

<p>
什么是 <code>Java Classes</code> ？在定义一个「类」的时候，会看到：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #9A93E1;">class</span> <span style="color: #A8CE93;">Person</span>{
    ...
}
</pre>
</div>

<p>
<code>class</code> 语法关键字，定义一个「类」，即 <a href="#org8132509">Java 对象（Object）</a> 的模板。「类」的存在形式是什么？根据不同的存在形式，就有了「类」的生命周期。
</p>

<p>
在 Java 程序的视角下：1) 编写代码时，「类」以 <code>.java</code> 文件的形式是存储在硬盘中；2) 程序编译后，「类」以 <code>.class</code> 二进制文本的形式（字节码）存储于硬盘中；3) 程序运行时，「类」放置于 JVM 分配的内存中。
</p>

<p>
可以知道的是，虽然类存储的形式不同了，但是，表示的含义是一样的，即 <code>描述 Java 对象的数据结构，定义了对象的状态以及行为</code> 。
</p>

<p>
类的生命周期，特指在程序运行时，一个类会经历怎么样的生命历程？从被加载到内存（诞生）中，算是，到被使用（贡献价值）后，被卸载（死亡），一个类是如何走过她的一生呢？
</p>

<p>
类的生杀大权掌握在&ldquo;判官&rdquo; Java 虚拟机（JVM）手上。
</p>


<figure id="orgf03a9ca">
<img src="atta_Java_类的生命周期/2022-07-05_16-08-09_screenshot.png" alt="2022-07-05_16-08-09_screenshot.png">

</figure>
</div>

<div id="outline-container-org0ea31a2" class="outline-3">
<h3 id="org0ea31a2"><span class="section-number-3">2.1.</span> 加载：查找字节码文件并载入内存</h3>
<div class="outline-text-3" id="text-2-1">
<p>
在程序编译后，JVM 首先需要根据唯一标识的类名找到 <code>.class</code> 文件，然后将文件中静态的数据结构，转换为 JVM 运行时所规范的数据结构，放入 JVM 内存的方法区中。并且根据数据结构生成一个 <code>Class&lt;T&gt;</code> 对象，放置于 JVM 内存的堆区。
</p>


<figure id="orge1c6220">
<img src="atta_Java_类的生命周期/2022-07-05_15-41-38_screenshot.png" alt="2022-07-05_15-41-38_screenshot.png">

</figure>


<figure id="org285d06d">
<img src="atta_Java_类的生命周期/2022-07-05_class_loader.png" alt="2022-07-05_class_loader.png">

</figure>
</div>
</div>

<div id="outline-container-org0e8b5e0" class="outline-3">
<h3 id="org0e8b5e0"><span class="section-number-3">2.2.</span> 连接</h3>
<div class="outline-text-3" id="text-2-2">
<p>
替换全局变量的一个过程。
</p>

<ol class="org-ol">
<li>验证类的安全性；</li>

<li>为类的静态变量分配内存并初始化为 JVM 默认值。比如基本类型，整数为 0，引用型为 <code>null</code> ，对于 <code>final static</code> 修饰的常量则会被赋值（用户定义的值）后放入到常量池中；</li>

<li>替换符号引用，比如类名，字段，方法名等符号替换成类似 <code>0X21344</code> 全局唯一的引用标识
ps: 在 debug 中就能看到每个变量的全局标识。</li>
</ol>
</div>
</div>

<div id="outline-container-org90f1b80" class="outline-3">
<h3 id="org90f1b80"><span class="section-number-3">2.3.</span> 初始化</h3>
<div class="outline-text-3" id="text-2-3">
<p>
初始化类变量，为静态变量赋予用户定义的初值，初始化父类的方法等。
</p>

<blockquote>
<ul class="org-ul">
<li>创建类的实例，也就是new的方式</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射(如Class.forName(&ldquo;com.pdai.jvm.Test&rdquo;))</li>
<li>初始化某个类的子类，则其父类也会被初始化</li>
<li>Java虚拟机启动时被标明为启动类的类(Java Test)，直接使用java.exe命令来运行某个主类</li>
</ul>
</blockquote>
</div>
</div>

<div id="outline-container-orge94b733" class="outline-3">
<h3 id="orge94b733"><span class="section-number-3">2.4.</span> 卸载</h3>
<div class="outline-text-3" id="text-2-4">
<p>
在使用结束后，将类从 JVM 中卸载。其包括正常退出结束和异常结束导致卸载。
</p>
</div>
</div>

<div id="outline-container-org3344549" class="outline-3">
<h3 id="org3344549"><span class="section-number-3">2.5.</span> 参见：<a href="https://pdai.tech/md/java/jvm/java-jvm-classload.html">https://pdai.tech/md/java/jvm/java-jvm-classload.html</a></h3>
</div>
</div>
<div id="outline-container-org8132509" class="outline-2">
<h2 id="org8132509"><span class="section-number-2">3.</span> lang.java.concept.object&#x2013;abstraction of code</h2>
<div class="outline-text-2" id="text-3">
<p>
<code>Object</code> 在 Java 中是一种代码抽象的基本单位。抽象是 <a href="#org254fad8">面向对象编程</a> 的核心，其基础是现实世界到计算机世界中对象的映射。【这里的对象其实是理解现实世界的一种途径（颇有哲学意味的话题）。】
</p>

<p>
现实世界的实体具有「状态」和「行为」两种特征。比如狗有状态（名字，颜色，品种，饿了）和行为（吃，叫，摇尾巴）。通过「状态」和「行为」就可以大概模拟实体之间交互的过程了。比如，狗和狗打架，你养了一只狗。
</p>

<p>
<code>Object</code> 在 Java 中可以被理解为抽象数据类型。其中包含「字段」和「方法」，分别对应现实对象的「状态」和「行为」。
</p>

<p>
Java 使用 <code>class</code> 作为 Object 的模板，提供定义 Object 状态和方法的途径。通过对模板实例化得到一个具体的 <code>Object</code> ，也就是 <code>class</code> 实例（instance）。如何定义一个 <code>Java class</code> 呢？使用 <code>class</code> 关键字可以定义一个 =Java class=。
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #9A93E1;">class</span> <span style="color: #A8CE93;">Person</span>{
    ...
}
</pre>
</div>

<p>
之所以使用对象，是因为将代码以对象为单位抽象，提供了一些好处：
</p>

<p>
比如，代码模块化、利用封装屏蔽细节、代码复用、更容易的代码替换和修复代码漏洞。
</p>

<p>
总的来说，面向对象编程，提供了一种编程的视角。在这个视角下，对象是基本的操作单位。什么继承，多态就是在对象基础上高效构建软件工程的模式。比如，通过继承和多态可以减少冗余代码的编写。
</p>

<p>
<b>在学习 Java 对象的时候，可以从两种特征出发，迅速掌握该对象是什么。噢，还应该加上继承关系。</b>
</p>
</div>

<div id="outline-container-orgbb19382" class="outline-3">
<h3 id="orgbb19382"><span class="section-number-3">3.1.</span> equals-hashCode-override</h3>
<div class="outline-text-3" id="text-3-1">
<p>
这四个东西，在自定义对象的时候似乎有时需要覆写或传入（Comparator），有时似乎又不用。
</p>

<p>
equals() 是继承自老祖宗 <code>Object</code> 。所有的对象都继承自 <code>Object</code> ，所以所有对象都有一个默认对比对象 hash 值的 <code>equals()</code> 方法。
</p>

<p>
todo: 补充其他方法的简介
</p>

<p>
为了解决何时需要使用这些东西，首先需要先确立这些方法或接口的使用场景。即，它们何时被需要。频繁使用的场景是「集合类」。
</p>

<p>
场景 1：当需要利用对象中的状态判断是否相等的时候需要在定义类时覆写 ~equals()~。比如，判断列表里面是否包含某个对象。
</p>

<p>
场景 2：当需要为一个对象生成一个唯一标识的时候，比如 Map 集合中，要确定唯一的键值（key）的时候。则 Map 中放入的对象需要覆写 hashCode() 方法。如果实现的 hashCode() 生成对象的 hashCode 越唯一，Map 的查找效率就越高。
</p>

<p>
场景 3：当需要在列表中实现
</p>


<p>
如果要用一个 List 来存储你自定义的对象，那么，当要使用 List 中的 <code>contains()</code> 或 <code>indexOf()</code> ，那么就必须实现。因为这些方法利用 <code>equals</code> 方法来判定对象是否相等。
</p>

<p>
如何覆写呢？Java 的 equals 实现需要满足等价类的定义：自反、对称、传递和一致。
</p>

<p>
因此，我们总结一下 equals() 方法的正确编写方法：
</p>

<ol class="org-ol">
<li>先确定实例“相等”的逻辑，即哪些字段相等，就认为实例相等；</li>
<li>用 <code>instanceof</code> 判断传入的待比较的 Object 是不是当前类型，如果是，继续比较，否则，返回 ~false~；</li>
<li>对引用类型用 <code>Objects.equals()</code> 比较，对基本类型直接用==比较。</li>
</ol>

<p>
<b>使用 <code>Objects.equals()</code> 比较两个引用类型是否相等的目的是省去了判断 null 的麻烦。两个引用类型都是 null 时它们也是相等的</b> 。
</p>

<p>
如果不调用 List 的 contains()、indexOf() 这些方法，那么放入的元素就不需要实现 equals() 方法。
</p>

<p>
参见：<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1265116446975264">编写 equals 方法</a>
</p>
</div>
</div>

<div id="outline-container-org6eeacfe" class="outline-3">
<h3 id="org6eeacfe"><span class="section-number-3">3.2.</span> 参见：</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li><a href="https://docs.oracle.com/javase/tutorial/java/concepts/object.html">https://docs.oracle.com/javase/tutorial/java/concepts/object.html</a></li>
<li><a href="https://en.wikipedia.org/wiki/Object-oriented_programming">https://en.wikipedia.org/wiki/Object-oriented_programming</a></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org1f7768f" class="outline-2">
<h2 id="org1f7768f"><span class="section-number-2">4.</span> lang.java.concept.classpath&#x2013;url to locate class</h2>
<div class="outline-text-2" id="text-4">
<blockquote>
<p>
首先你要知道java这个指令是作什麽用的？
<b>执行java，其实就是启动JVM，之后接下类别名称，表示由JVM载入该类别的.class并执行。</b>
</p>
</blockquote>

<p>
在理解 CLASSPATH 之前，需要先理解 Class 是什么。
</p>

<p>
Class 是字节码文件，Java 启动的过程就是，启动 Jvm 虚拟机然后加载 .class 文件执行。
</p>

<p>
CLASSPATH 其实就是告诉 Jvm 在哪里找到所需要的 .class 文件。
</p>

<p>
所以，用 Java 命令执行 Jar 压缩包里面的类时，需要使用 -classpath(-cp) 参数指定 .class 文件的位置。
</p>

<pre class="example">
java -cp target/my-app-1.0-SNAPSHOT.jar com.mycompany.app.App

</pre>
</div>

<div id="outline-container-orga247941" class="outline-3">
<h3 id="orga247941"><span class="section-number-3">4.1.</span> 方法参数传递</h3>
<div class="outline-text-3" id="text-4-1">
<ul class="org-ul">
<li>基本类型参数的传递，是调用方值的复制。双方各自的后续修改，互不影响。</li>
<li>引用类型参数的传递，调用方的变量，和接收方的参数变量，指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方（因为指向同一个对象嘛）。</li>
</ul>
</div>
</div>

<div id="outline-container-orgcc8b54d" class="outline-3">
<h3 id="orgcc8b54d"><span class="section-number-3">4.2.</span> References</h3>
<div class="outline-text-3" id="text-4-2">
<p>
良葛格 (2014) CLASSPATH 是什麼？, OPENHOME.CC. Available at: <a href="https://openhome.cc/Gossip/JavaEssence/WhatClasspath.html">https://openhome.cc/Gossip/JavaEssence/WhatClasspath.html</a> (Accessed: 2 March 2022).
</p>
</div>
</div>
</div>

<div id="outline-container-org254fad8" class="outline-2">
<h2 id="org254fad8"><span class="section-number-2">5.</span> lang.java.concept.object_oriented_programming&#x2013;code abstraction base on object</h2>
<div class="outline-text-2" id="text-5">
<p>
面向对象是一种编程范式，以 <a href="#org8132509">lang.java.object</a> 为基本单位提供代码抽象的模式。
</p>

<p>
面向对象的核心是抽象。为了保证抽象这一特性，Java 提供封装、<a href="#orgc36b931">lang.java.feat.inheritance&#x2013;mechanism to reuse code (field-method) </a>和 <a href="#orgc027445">lang.java.feat.polymorphism&#x2013;mechanism-to-seperate-code</a>。
</p>
</div>
<div id="outline-container-org0d8c456" class="outline-3">
<h3 id="org0d8c456"><span class="section-number-3">5.1.</span> Encapsulation</h3>
<div class="outline-text-3" id="text-5-1">
<p>
一个典型的对象包含「状态」和「行为」，通过对象提供的行为（方法），可以改变对象内部的状态（字段）。以对象为基本单位编程，对外提供编写者希望暴露的方法，隐藏对象内部的实现细节。这就是封装。
</p>
</div>
</div>

<div id="outline-container-org58b3fcb" class="outline-3">
<h3 id="org58b3fcb"><span class="section-number-3">5.2.</span> Reference</h3>
<div class="outline-text-3" id="text-5-2">
<blockquote>
<p>
When you want to purchase a car, the car dealer gives you the details of
available colors, seating capacity, engine, gearbox, type of steering and other
kinds of general details. The car dealer never tells you specific (complex)
details of material being used for the hood, nuts and bolts and such.
abstraction car parts
</p>

<p>
The above details are not needed. These details are hidden by the car dealer.
Like this, you can think of other examples in the real world. Abstraction is
everywhere. - <a href="https://www.startertutorials.com/corejava/object-orientation-principles.html">startertutorials</a>
</p>
</blockquote>
</div>
</div>
</div>

<div id="outline-container-orgc36b931" class="outline-2">
<h2 id="orgc36b931"><span class="section-number-2">6.</span> lang.java.feat.inheritance&#x2013;Mechanism to reuse code (field-method)</h2>
<div class="outline-text-2" id="text-6">
<p>
假设在定义三个不同的类，它们拥有相同的 100 个属性，只有 3 个属性不同。如果每个类都需要写 100 个字段，这样会产生两倍的冗余代码，有什么办法可以解决呢？
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #9A93E1;">class</span> <span style="color: #A8CE93;">Person</span> {
    <span style="color: #9A93E1;">private</span> <span style="color: #A8CE93;">String</span> <span style="color: #DF8C8C;">name</span>;
    <span style="color: #9A93E1;">private</span> <span style="color: #A8CE93;">int</span> <span style="color: #DF8C8C;">age</span>;
    <span style="color: #899BA6;">//</span><span style="color: #899BA6;">... &#27492;&#22788;&#30465;&#30053;100&#20010;</span>

    <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">String</span> <span style="color: #83AFE5;">getName</span>() {...}
    <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">setName</span>(<span style="color: #A8CE93;">String</span> <span style="color: #DF8C8C;">name</span>) {...}
    <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">int</span> <span style="color: #83AFE5;">getAge</span>() {...}
    <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">setAge</span>(<span style="color: #A8CE93;">int</span> <span style="color: #DF8C8C;">age</span>) {...}
}
<span style="color: #9A93E1;">class</span> <span style="color: #A8CE93;">Student</span> {
    <span style="color: #9A93E1;">private</span> <span style="color: #A8CE93;">String</span> <span style="color: #DF8C8C;">name</span>;
    <span style="color: #9A93E1;">private</span> <span style="color: #A8CE93;">int</span> <span style="color: #DF8C8C;">age</span>;
    <span style="color: #899BA6;">//</span><span style="color: #899BA6;">... &#27492;&#22788;&#30465;&#30053;100&#20010;&#21644; Person &#30456;&#21516;&#30340;&#23646;&#24615;</span>
    <span style="color: #9A93E1;">private</span> <span style="color: #A8CE93;">int</span> <span style="color: #DF8C8C;">score</span>;

    <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">String</span> <span style="color: #83AFE5;">getName</span>() {...}
    <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">setName</span>(<span style="color: #A8CE93;">String</span> <span style="color: #DF8C8C;">name</span>) {...}
    <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">int</span> <span style="color: #83AFE5;">getAge</span>() {...}
    <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">setAge</span>(<span style="color: #A8CE93;">int</span> <span style="color: #DF8C8C;">age</span>) {...}
    <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">int</span> <span style="color: #83AFE5;">getScore</span>() { &#8230; }
    <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">setScore</span>(<span style="color: #A8CE93;">int</span> <span style="color: #DF8C8C;">score</span>) { &#8230; }
}
</pre>
</div>

<p>
在代码语义层面，继承提供了共同代码的抽取。比如，不同类间，相同的实例变量，一个方法的共同实现。将上述示例中，相同的字段提取到类 Person 中。类 Student 通过继承，就获得了 Person 中的所有实例变量了。
</p>

<p>
在对象逻辑层面，继承提供了 B 是 A 的抽象，比如 Student 是 Person，所以其在代码语义上共享属性和方法定义。
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #9A93E1;">class</span> <span style="color: #A8CE93;">Person</span> {
    <span style="color: #9A93E1;">private</span> <span style="color: #A8CE93;">String</span> <span style="color: #DF8C8C;">name</span>;
    <span style="color: #9A93E1;">private</span> <span style="color: #A8CE93;">int</span> <span style="color: #DF8C8C;">age</span>;
    <span style="color: #899BA6;">//</span><span style="color: #899BA6;">... &#27492;&#22788;&#30465;&#30053;100&#20010;&#20849;&#26377;&#23383;&#27573;</span>

    <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">String</span> <span style="color: #83AFE5;">getName</span>() {...}
    <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">setName</span>(<span style="color: #A8CE93;">String</span> <span style="color: #DF8C8C;">name</span>) {...}
    <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">int</span> <span style="color: #83AFE5;">getAge</span>() {...}
    <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">setAge</span>(<span style="color: #A8CE93;">int</span> <span style="color: #DF8C8C;">age</span>) {...}
}

<span style="color: #9A93E1;">class</span> <span style="color: #A8CE93;">Student</span> <span style="color: #9A93E1;">extends</span> <span style="color: #A8CE93;">Person</span> {
    <span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#19981;&#35201;&#37325;&#22797;name&#21644;age&#23383;&#27573;/&#26041;&#27861;,</span>
    <span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#21482;&#38656;&#35201;&#23450;&#20041;&#26032;&#22686;score&#23383;&#27573;/&#26041;&#27861;:</span>
    <span style="color: #9A93E1;">private</span> <span style="color: #A8CE93;">int</span> <span style="color: #DF8C8C;">score</span>;

    <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">int</span> <span style="color: #83AFE5;">getScore</span>() { &#8230; }
    <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">setScore</span>(<span style="color: #A8CE93;">int</span> <span style="color: #DF8C8C;">score</span>) { &#8230; }
}
</pre>
</div>
</div>

<div id="outline-container-org32a0bc8" class="outline-3">
<h3 id="org32a0bc8"><span class="section-number-3">6.1.</span> inheritance.method-call-priority</h3>
<div class="outline-text-3" id="text-6-1">
<blockquote>
<p>
首先我们先看一句话：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。这句话对多态进行了一个概括。其实在继承链中对象方法的调用存在一个优先级：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。
</p>

<p>
<a href="https://www.cnblogs.com/chenssy/p/3372798.html">https://www.cnblogs.com/chenssy/p/3372798.html</a>
</p>
</blockquote>

<p>
在调用对象的实例方法时，Java 编译器如何找到实际的调用方法呢？这里涉及到继承链的方法调用优先级。假设调用的方法是 <code>show(object)</code> ， <code>object</code> 是一个对象。 1）优先调用 this 中的方法；2）如果 this 中不存在 <code>show(object) ，则调用 =super.show(object)</code> ；3）既然关于 <code>show(object)</code> 方法都不存在于继承链中，那么就尝试将参数 <code>object</code> 向上转型。再尝试调用 <code>this.show((super)object)</code> 。4）如果 this 还是不存在关于 <code>super.show(object)</code> 的方法，则调用 <code>super.show((super)object)</code> 。既然编译器尝试向上寻找那么多次都没有办法找到方法，则判定方法未定义，编译错误。
</p>

<p>
在「引用类型和被引用类型」相同的情况下
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">class</span> <span style="color: #A8CE93;">Test</span> {
    <span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">static</span> <span style="color: #9A93E1;">class</span> <span style="color: #A8CE93;">Father</span>{
        <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">String</span> <span style="color: #83AFE5;">show</span>(<span style="color: #A8CE93;">Son</span> <span style="color: #DF8C8C;">obj</span>) {
            <span style="color: #9A93E1;">return</span> (<span style="color: #7FC1CA;">"Father show Son"</span>);
        }
        <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">String</span> <span style="color: #83AFE5;">show</span>(<span style="color: #A8CE93;">GrandSon</span> <span style="color: #DF8C8C;">obj</span>) {
            <span style="color: #9A93E1;">return</span> (<span style="color: #7FC1CA;">"Father show GrandSon"</span>);
        }
    }
    <span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">static</span> <span style="color: #9A93E1;">class</span> <span style="color: #A8CE93;">Son</span> <span style="color: #9A93E1;">extends</span> <span style="color: #A8CE93;">Father</span>{
        <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">String</span> <span style="color: #83AFE5;">show</span>(<span style="color: #A8CE93;">Son</span> <span style="color: #DF8C8C;">obj</span>) {
            <span style="color: #9A93E1;">return</span> (<span style="color: #7FC1CA;">"Son show Son"</span>);
        }
    }
    <span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">static</span> <span style="color: #9A93E1;">class</span> <span style="color: #A8CE93;">GrandSon</span> <span style="color: #9A93E1;">extends</span> <span style="color: #A8CE93;">Son</span>{
    }

    <span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">static</span> <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">main</span>(<span style="color: #A8CE93;">String</span>[] <span style="color: #DF8C8C;">args</span>) {
        <span style="color: #A8CE93;">Son</span> <span style="color: #DF8C8C;">son1</span> = <span style="color: #9A93E1;">new</span> <span style="color: #A8CE93;">Son</span>();
        <span style="color: #A8CE93;">GrandSon</span> <span style="color: #DF8C8C;">grandSon</span> = <span style="color: #9A93E1;">new</span> <span style="color: #A8CE93;">GrandSon</span>();
        <span style="color: #A8CE93;">Son</span> <span style="color: #DF8C8C;">son2</span> = <span style="color: #9A93E1;">new</span> <span style="color: #A8CE93;">Son</span>();

        System.out.println(<span style="color: #7FC1CA;">"1--"</span> + son1.show(son2));
        <span style="color: #899BA6;">// </span><span style="color: #899BA6;">-&gt; Son show Son</span>
        <span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#22240;&#20026; this &#25351;&#20195;&#30340;&#26159; son1&#65292;this &#22312; Son &#31867;&#22411;&#20013;&#25214;&#21040;&#20102;&#23545;&#24212;&#30340;&#26041;&#27861;</span>
        <span style="color: #899BA6;">// </span><span style="color: #899BA6;">public String show(Son obj)</span>
        System.out.println(<span style="color: #7FC1CA;">"2--"</span> + son1.show(grandSon));
        <span style="color: #899BA6;">// </span><span style="color: #899BA6;">-&gt; Father show GrandSon</span>
        <span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#22240;&#20026; this &#25351;&#20195;&#30340;&#26159; son1&#65292;this &#22312; Son &#31867;&#22411;&#20013;&#25214;&#19981;&#21040;&#23545;&#24212;&#30340;&#26041;&#27861;&#65292;&#25152;&#20197;&#32534;&#35793;&#22120;&#20250;&#21521;&#20854;&#29238;&#31867;&#23547;&#25214;&#26159;&#21542;&#26377; public String show(GrandSon obj) &#26041;&#27861;&#12290;&#22312;&#29238;&#31867;&#20013;&#25214;&#21040;&#65292;&#25152;&#20197;&#35843;&#29992; super.show(grandSon)</span>
    }
}
</pre>
</div>

<p>
这一继承链优先级同样适用于「被引用类型是引用类型的子类」的情况，即多态调用的情况。
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">class</span> <span style="color: #A8CE93;">TestPolymorphism</span> {
    <span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">static</span> <span style="color: #9A93E1;">class</span> <span style="color: #A8CE93;">A</span> {
        <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">String</span> <span style="color: #83AFE5;">show</span>(<span style="color: #A8CE93;">D</span> <span style="color: #DF8C8C;">obj</span>) {
            <span style="color: #9A93E1;">return</span> (<span style="color: #7FC1CA;">"A and D"</span>);
        }
        <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">String</span> <span style="color: #83AFE5;">show</span>(<span style="color: #A8CE93;">A</span> <span style="color: #DF8C8C;">obj</span>) {
            <span style="color: #9A93E1;">return</span> (<span style="color: #7FC1CA;">"A and A"</span>);
        }
        <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">String</span> <span style="color: #83AFE5;">show</span>(<span style="color: #A8CE93;">E</span> <span style="color: #DF8C8C;">obj</span>) {
            <span style="color: #9A93E1;">return</span> (<span style="color: #7FC1CA;">"A and E"</span>);
        }
    }

    <span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">static</span> <span style="color: #9A93E1;">class</span> <span style="color: #A8CE93;">B</span> <span style="color: #9A93E1;">extends</span> <span style="color: #A8CE93;">A</span> {
        <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">String</span> <span style="color: #83AFE5;">show</span>(<span style="color: #A8CE93;">B</span> <span style="color: #DF8C8C;">obj</span>) {
            <span style="color: #9A93E1;">return</span> (<span style="color: #7FC1CA;">"B and B"</span>);
        }
        <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">String</span> <span style="color: #83AFE5;">show</span>(<span style="color: #A8CE93;">A</span> <span style="color: #DF8C8C;">obj</span>) {
            <span style="color: #9A93E1;">return</span> (<span style="color: #7FC1CA;">"B and A"</span>);
        }
    }
    <span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">static</span> <span style="color: #9A93E1;">class</span> <span style="color: #A8CE93;">C</span> <span style="color: #9A93E1;">extends</span> <span style="color: #A8CE93;">B</span> { }
    <span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">static</span> <span style="color: #9A93E1;">class</span> <span style="color: #A8CE93;">D</span> <span style="color: #9A93E1;">extends</span> <span style="color: #A8CE93;">B</span> { }
    <span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">static</span> <span style="color: #9A93E1;">class</span> <span style="color: #A8CE93;">E</span> <span style="color: #9A93E1;">extends</span> <span style="color: #A8CE93;">A</span>{ }

    <span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">static</span> <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">main</span>(<span style="color: #A8CE93;">String</span>[] <span style="color: #DF8C8C;">args</span>) {
        <span style="color: #A8CE93;">A</span> <span style="color: #DF8C8C;">a1</span> = <span style="color: #9A93E1;">new</span> <span style="color: #A8CE93;">A</span>();
        <span style="color: #A8CE93;">A</span> <span style="color: #DF8C8C;">a2</span> = <span style="color: #9A93E1;">new</span> <span style="color: #A8CE93;">B</span>();
        <span style="color: #A8CE93;">B</span> <span style="color: #DF8C8C;">b</span> = <span style="color: #9A93E1;">new</span> <span style="color: #A8CE93;">B</span>();
        <span style="color: #A8CE93;">C</span> <span style="color: #DF8C8C;">c</span> = <span style="color: #9A93E1;">new</span> <span style="color: #A8CE93;">C</span>();
        <span style="color: #A8CE93;">D</span> <span style="color: #DF8C8C;">d</span> = <span style="color: #9A93E1;">new</span> <span style="color: #A8CE93;">D</span>();
        <span style="color: #A8CE93;">E</span> <span style="color: #DF8C8C;">e</span> = <span style="color: #9A93E1;">new</span> <span style="color: #A8CE93;">E</span>();

        System.out.println(<span style="color: #7FC1CA;">"1--"</span> + a1.show(b)); <span style="color: #899BA6;">// </span><span style="color: #899BA6;">this &#30340;&#31867;&#22411;&#20026; A&#65292;&#20248;&#20808;&#31867; A &#30340;&#26041;&#27861;&#65292;&#20294;&#19981;&#20250;&#21521;&#23376;&#31867;&#23547;&#25214;&#65292;&#38500;&#38750;&#23376;&#31867;&#23454;&#29616;&#20102;&#31867; A &#23450;&#20041;&#30340;&#26041;&#27861;&#12290;</span>
        System.out.println(<span style="color: #7FC1CA;">"2--"</span> + a1.show(c));
        System.out.println(<span style="color: #7FC1CA;">"3--"</span> + a1.show(d));
        System.out.println(<span style="color: #7FC1CA;">"4--"</span> + a2.show(b)); <span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#30001;&#20110;&#22810;&#24577;&#30340;&#21152;&#20837;&#65292;&#34987;&#24341;&#29992;&#31867;&#22411;&#20026; B&#12290;&#31532;&#19968;&#27425;&#23547;&#25214;&#65292;&#31867; A &#26159;&#21542;&#20855;&#26377; show(B obj) &#30340;&#26041;&#27861;&#65292;&#22914;&#26524;&#27809;&#26377;&#23601;&#21040; A &#30340;&#29238;&#31867;&#23547;&#25214;&#65292;&#20063;&#25214;&#19981;&#21040;&#65292;&#36827;&#34892;&#31532;&#19977;&#27493;&#23547;&#25214;&#65292;&#23558; b &#21521;&#19978;&#36716;&#22411;&#65292;&#30475;&#26159; this &#26159;&#21542;&#21547;&#26377; show(super(b)) &#30340;&#26041;&#27861;&#12290;&#25214;&#21040;&#20102; show(A obj)&#65292;&#21363;&#24471;&#21040; A and A &#30340;&#32467;&#26524;&#12290;</span>
        System.out.println(<span style="color: #7FC1CA;">"5--"</span> + a2.show(c));
        System.out.println(<span style="color: #7FC1CA;">"6--"</span> + a2.show(d));
        System.out.println(<span style="color: #7FC1CA;">"7--"</span> + b.show(b));
        System.out.println(<span style="color: #7FC1CA;">"8--"</span> + b.show(c));
        System.out.println(<span style="color: #7FC1CA;">"9--"</span> + b.show(d));
        System.out.println(<span style="color: #7FC1CA;">"10--"</span> + b.show(e));
    }
}

</pre>
</div>

<p>
所谓的多态就是，同样的状态，在不同的对象中以不同的形式展现，就是多态。
</p>

<p>
总的来说，通过封装、继承和多态，我们可以站在一种新的视角进行编程。相较于面向过程的编程范式，代码可以更加的独立，便于使用。
</p>
</div>
</div>
</div>
<div id="outline-container-orgc027445" class="outline-2">
<h2 id="orgc027445"><span class="section-number-2">7.</span> lang.java.feat.polymorphism&#x2013;Mechanism-to-seperate-code</h2>
<div class="outline-text-2" id="text-7">
<ul class="org-ul">
<li>子类可以覆写父类的方法（Override），覆写在子类中改变了父类方法的行为；</li>

<li>Java的方法调用总是作用于运行期对象的实际类型，这种行为称为多态；</li>
</ul>
</div>

<div id="outline-container-org9fde269" class="outline-3">
<h3 id="org9fde269"><span class="section-number-3">7.1.</span> 多态意味着面向抽象编程</h3>
<div class="outline-text-3" id="text-7-1">
<p>
抽象类设置一种规范，继承该抽象类的子类必须覆写其抽象方法。
</p>

<p>
<b>抽象类不可被实例化</b> 。
</p>

<p>
在使用方法时，使用抽象类作为参数，屏蔽了底层实现的多样性。
</p>

<p>
这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。
</p>

<p>
面向抽象编程的本质就是：
</p>

<p>
上层代码只定义规范（例如：abstract class Person）；
</p>

<p>
不需要子类就可以实现业务逻辑（正常编译），比如，定义只定义传入（接口的函数，只要实现了该接口的对象都可以传入）；
</p>

<p>
具体的业务逻辑由不同的子类实现，调用者并不关心。
</p>
</div>
</div>

<div id="outline-container-org1b8e411" class="outline-3">
<h3 id="org1b8e411"><span class="section-number-3">7.2.</span> polymorphism.example</h3>
<div class="outline-text-3" id="text-7-2">
<ol class="org-ol">
<li>使用集合接口接收实现了该接口的对象。接口越抽象，代码复用度和代码封装得越好。</li>
<li>使用迭代器（Iterator）遍历集合对象，集合们各自实现了高效的遍历方式，调用者使用迭代器不需要知道迭代器实现的细节。</li>
<li>设计模式-工厂 和 设计模式-策略 均运用了多态。
通过持有抽象接口，接收实现类型而返回具体的实现。</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org7d3987c" class="outline-2">
<h2 id="org7d3987c"><span class="section-number-2">8.</span> lang.java.feat.auto_boxing&#x2013;Box of basic data type</h2>
<div class="outline-text-2" id="text-8">
<p>
包装类是将基本变量类型用类包装起来。
</p>

<p>
看示例理解自动包装和拆包装。拆包装可以会出现个惊喜 <code>null</code> 。
</p>

<div class="org-src-container">
<pre class="src src-java" id="org2eb726e"><span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">static</span> <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">main</span>(<span style="color: #A8CE93;">String</span>[] <span style="color: #DF8C8C;">args</span>) {
    <span style="color: #A8CE93;">int</span> <span style="color: #DF8C8C;">i</span> = <span style="color: #7FC1CA; font-weight: bold;">100</span>;
    <span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#36890;&#36807;new&#25805;&#20316;&#31526;&#21019;&#24314;Integer&#23454;&#20363;(&#19981;&#25512;&#33616;&#20351;&#29992;,&#20250;&#26377;&#32534;&#35793;&#35686;&#21578;):</span>
    <span style="color: #A8CE93;">Integer</span> <span style="color: #DF8C8C;">n1</span> = <span style="color: #9A93E1;">new</span> <span style="color: #A8CE93;">Integer</span>(i);
    <span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#36890;&#36807;&#38745;&#24577;&#26041;&#27861;valueOf(int)&#21019;&#24314;Integer&#23454;&#20363;:</span>
    <span style="color: #A8CE93;">Integer</span> <span style="color: #DF8C8C;">n2</span> = Integer.valueOf(i);
    <span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#36890;&#36807;&#38745;&#24577;&#26041;&#27861;valueOf(String)&#21019;&#24314;Integer&#23454;&#20363;:</span>
    <span style="color: #A8CE93;">Integer</span> <span style="color: #DF8C8C;">n3</span> = Integer.valueOf(<span style="color: #7FC1CA;">"100"</span>);
    System.out.println(n3.intValue());
    <span style="color: #A8CE93;">Integer</span> <span style="color: #DF8C8C;">n</span> = <span style="color: #7FC1CA; font-weight: bold;">100</span>; <span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#32534;&#35793;&#22120;&#33258;&#21160;&#20351;&#29992;Integer.valueOf(int) &#12304;&#33258;&#21160;&#35013;&#31665;&#12305;</span>
    <span style="color: #A8CE93;">int</span> <span style="color: #DF8C8C;">x</span> = n; <span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#32534;&#35793;&#22120;&#33258;&#21160;&#20351;&#29992;Integer.intValue() &#12304;&#33258;&#21160;&#25286;&#31665;&#65292;&#21487;&#33021;&#20250;&#23548;&#33268; null&#12305;</span>

}

</pre>
</div>

<pre class="example">
100
</pre>


<ul class="org-ul">
<li>int == Integer：均比较值的大小，Integer 会自动拆箱</li>
<li>Integer == Integer：会以 Integer 的形式比较，*比较对象的地址*
<ol class="org-ol">
<li>new 是一定返回一个新的对象</li>
<li>valueOf（静态工厂方法）在 [-128，127] 之内会返回同一缓存对象，超过此范围返回一个新对象。</li>
</ol></li>
<li>包装类是对象，所以需要使用 equals 进行判等</li>
</ul>
</div>
</div>

<div id="outline-container-org2bdf07f" class="outline-2">
<h2 id="org2bdf07f"><span class="section-number-2">9.</span> lang.java.feat.reflection&#x2013;Mechanism to manipulate class</h2>
<div class="outline-text-2" id="text-9">
<p>
在知道什么是反射前，需要了解一下 <a href="#orgf4d0365">Java 类的生命周期</a>。
</p>

<p>
Java 程序的生命周期包括：编写、编译、运行（在 JVM 上运行字节码）。
</p>

<p>
反射能让 Java 程序在获取一个运行期间 <a href="#org8132509">Java 对象（Object）</a> 的所有信息。比如，字段和方法。
</p>

<p>
class 的生命周期包括加载、链接、初始化、使用和卸载。在程序运行期间，如果 JVM 需要使用到某个 class A 时，会加载类 A。加载类 A 时会创建一个 <code>Class&lt;A&gt;</code> 类来记录类 A 所有的信息。
</p>

<p>
通过 <code>Class</code> 类能获取类的信息和操作类的方法就是反射。简单来说就是使用 <code>Class</code> 类。
</p>

<p>
Java 通过 java.lang.reflect 包提供操纵 Class 对象的 API。
</p>
</div>

<div id="outline-container-org03575bb" class="outline-3">
<h3 id="org03575bb"><span class="section-number-3">9.1.</span> 获取「类」的 Class&lt;T&gt; 对象</h3>
<div class="outline-text-3" id="text-9-1">
<p>
方法一：直接通过一个class的静态变量class获取：
</p>

<p>
<code>Class cls = String.class;</code>
</p>

<p>
方法二：如果我们有一个实例变量，可以通过该实例变量提供的getClass()方法获取：
</p>

<p>
<code>String s = "Hello";</code>
<code>Class cls = s.getClass();</code>
</p>

<p>
方法三：如果知道一个class的完整类名，可以通过静态方法Class.forName()获取：
</p>

<p>
<code>Class cls = Class.forName("java.lang.String");</code>
</p>
</div>
</div>

<div id="outline-container-orgb860f6e" class="outline-3">
<h3 id="orgb860f6e"><span class="section-number-3">9.2.</span> 操作字段通过 Class&lt;T&gt; 中的 Field 相关方法</h3>
<div class="outline-text-3" id="text-9-2">
<p>
参见：<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1264803678201760">反射字段-lxf</a>
</p>
</div>
</div>

<div id="outline-container-orgf431c89" class="outline-3">
<h3 id="orgf431c89"><span class="section-number-3">9.3.</span> 操作方法通过 Class&lt;T&gt; 中的 Method 相关方法</h3>
<div class="outline-text-3" id="text-9-3">
<p>
参见：<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1264803678201760">反射方法-lxf</a>
</p>
</div>
</div>
</div>

<div id="outline-container-org9221c00" class="outline-2">
<h2 id="org9221c00"><span class="section-number-2">10.</span> lang.java.feat.access_level_modifiers&#x2013;Mechanism to restrict scope of access</h2>
<div class="outline-text-2" id="text-10">
<p>
Java 使用 <code>public~、~private~、~protected</code> 和 <code>friendly</code> 对「变量」和「方法」的作用域进行限定。若代码没有使用访问修饰符时，默认作用域为 ~friendly~。
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">作用域</td>
<td class="org-left">当前类</td>
<td class="org-left">同一package</td>
<td class="org-left">子孙类</td>
<td class="org-left">其他package</td>
</tr>

<tr>
<td class="org-left">public</td>
<td class="org-left">√</td>
<td class="org-left">√</td>
<td class="org-left">√</td>
<td class="org-left">√</td>
</tr>

<tr>
<td class="org-left">protected</td>
<td class="org-left">√</td>
<td class="org-left">√</td>
<td class="org-left">√</td>
<td class="org-left">×</td>
</tr>

<tr>
<td class="org-left">friendly(default)</td>
<td class="org-left">√</td>
<td class="org-left">√</td>
<td class="org-left">×</td>
<td class="org-left">×</td>
</tr>

<tr>
<td class="org-left">private</td>
<td class="org-left">√</td>
<td class="org-left">×</td>
<td class="org-left">×</td>
<td class="org-left">×</td>
</tr>
</tbody>
</table>

<p>
作用域范围 -&gt; 变大。
</p>

<p>
For accessing to the protected method, one option is using <a href="#org3e5b81a">lang.java.feat.anonymous-class.access-to-protected-method-in-other-package</a>
</p>
</div>

<div id="outline-container-org1937ffb" class="outline-3">
<h3 id="org1937ffb"><span class="section-number-3">10.1.</span> Reference</h3>
<div class="outline-text-3" id="text-10-1">
<ul class="org-ul">
<li><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html">Oracle Java Tutorials: Controlling Access to Members of a Class</a></li>
<li><blockquote>
<p>
只要记住了有4种访问权限，4个访问范围，然后将全选和范围在水平和垂直方向上分别按排从小到大或从大到小的顺序排列，就很容易画出上面的图了。——<a href="https://github.com/CoderLeixiaoshuai/java-eight-part/blob/master/docs/java/base/Java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A880%E9%97%AE.md#10%E4%BD%BF%E7%94%A8final%E5%85%B3%E9%94%AE%E5%AD%97%E4%BF%AE%E9%A5%B0%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E6%97%B6%E6%98%AF%E5%BC%95%E7%94%A8%E4%B8%8D%E8%83%BD%E5%8F%98%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%B8%8D%E8%83%BD%E5%8F%98">Java 基础入门 80 问</a>
</p>
</blockquote></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgb1e4f6c" class="outline-2">
<h2 id="orgb1e4f6c"><span class="section-number-2">11.</span> lang.java.feat.exception&#x2013;Mechanism to deal with error of code</h2>
<div class="outline-text-2" id="text-11">
</div>
<div id="outline-container-orgbe38206" class="outline-3">
<h3 id="orgbe38206"><span class="section-number-3">11.1.</span> lang.java.feat.exception.claim-to-catch</h3>
<div class="outline-text-3" id="text-11-1">
<p>
异常是一个类。Java 定义了一些常见的错误类型。当一个方法「throw」一个异常，则调用该方法时，需要在上层的调用栈中进行异常的捕获，否则代码会编译错误。
</p>
</div>
</div>

<div id="outline-container-orgd17358f" class="outline-3">
<h3 id="orgd17358f"><span class="section-number-3">11.2.</span> lang.java.feat.exception.type</h3>
<div class="outline-text-3" id="text-11-2">

<figure id="orgf4b2ab4">
<img src="atta_java_基础/2022-03-10_20-09-39_screenshot.png" alt="2022-03-10_20-09-39_screenshot.png">

</figure>

<p>
所有异常继承 Throwable 。Error 和 Exception 是两种异常体系。
</p>

<p>
Error 为严重的错误，一般为关乎资源分配的问题，（如内存，栈等）导致程序无法运行。
</p>

<p>
Exception 分为运行时的错误和非运行时的错误。其中，非运行时的错误必须捕获。
</p>
</div>
</div>

<div id="outline-container-org643bd03" class="outline-3">
<h3 id="org643bd03"><span class="section-number-3">11.3.</span> lang.java.feat.exception.throw-example</h3>
<div class="outline-text-3" id="text-11-3">
<ol class="org-ol">
<li>创建 Exception 的实例。</li>
<li>使用 throw 抛出</li>
</ol>


<p>
<code>throw new NullPointerException();</code>
</p>

<p>
完成了上述两件事情，如果不用这样写，需要以下写法。
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">process2</span>(<span style="color: #A8CE93;">String</span> <span style="color: #DF8C8C;">s</span>) {
    <span style="color: #9A93E1;">if</span> (s==<span style="color: #7FC1CA;">null</span>) {
        <span style="color: #A8CE93;">NullPointerException</span> <span style="color: #DF8C8C;">e</span> = <span style="color: #9A93E1;">new</span> <span style="color: #A8CE93;">NullPointerException</span>();
        <span style="color: #9A93E1;">throw</span> e;
    }
}

</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org868300c" class="outline-2">
<h2 id="org868300c"><span class="section-number-2">12.</span> lang.java.feat.anonymous_class&#x2013;Mechanism to deliver interface to methods</h2>
<div class="outline-text-2" id="text-12">
</div>
<div id="outline-container-org79c980f" class="outline-3">
<h3 id="org79c980f"><span class="section-number-3">12.1.</span> Definition</h3>
<div class="outline-text-3" id="text-12-1">
<p>
This code shows that creating an anonymous class means hoding an instance of an interface or an superclass as well as manifesting the abstraction oriented programming. That is to say, an anonymous class is the subtype of a class.
</p>

<blockquote>
<p>
HelloWorld frenchGreeting = new HelloWorld() {
    String name = &ldquo;tout le monde&rdquo;;
    public void greet() {
        greetSomeone(&ldquo;tout le monde&rdquo;);
    }
    public void greetSomeone(String someone) {
        name = someone;
        System.out.println(&ldquo;Salut &rdquo; + name);
    }
};
interface HelloWorld {
    public void greet();
    public void greetSomeone(String someone);
}
</p>
</blockquote>

<p>
An anonymous class use for implementing an interface or extending a class, which holds the true implementing of a method declaration.
</p>

<p>
An example of the difference of the definition between a normal local class and a anonymous class.
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">static</span> <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">main</span>(<span style="color: #A8CE93;">String</span>[] <span style="color: #DF8C8C;">args</span>) {
    <span style="color: #A8CE93;">HashMap</span>&lt;<span style="color: #A8CE93;">String</span>, <span style="color: #A8CE93;">String</span>&gt; <span style="color: #DF8C8C;">map1</span> = <span style="color: #9A93E1;">new</span> <span style="color: #A8CE93;">HashMap</span>&lt;&gt;();
    <span style="color: #A8CE93;">HashMap</span>&lt;<span style="color: #A8CE93;">String</span>, <span style="color: #A8CE93;">String</span>&gt; <span style="color: #DF8C8C;">map2</span> = <span style="color: #9A93E1;">new</span> <span style="color: #A8CE93;">HashMap</span>() {}; <span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#21311;&#21517;&#31867;!</span>
    <span style="color: #A8CE93;">HashMap</span>&lt;<span style="color: #A8CE93;">String</span>, <span style="color: #A8CE93;">String</span>&gt; <span style="color: #DF8C8C;">map3</span> = <span style="color: #9A93E1;">new</span> <span style="color: #A8CE93;">HashMap</span>() {
        {
            put(<span style="color: #7FC1CA;">"A"</span>, <span style="color: #7FC1CA;">"1"</span>);
            put(<span style="color: #7FC1CA;">"B"</span>, <span style="color: #7FC1CA;">"2"</span>);
        }
    };
    System.out.println(map1.getClass());
    System.out.println(map2.getClass());
    System.out.println(map3.getClass());
}

<span style="color: #899BA6;">/* </span><span style="color: #899BA6;">results:</span>
<span style="color: #899BA6;">    class java.util.HashMap</span>
<span style="color: #899BA6;">    class leetcode.editor.ds.TestInnerStaticClass$1</span>
<span style="color: #899BA6;">    class leetcode.editor.ds.TestInnerStaticClass$2</span>
<span style="color: #899BA6;">*/</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org3e5b81a" class="outline-3">
<h3 id="org3e5b81a"><span class="section-number-3">12.2.</span> Access to protected method in other package</h3>
<div class="outline-text-3" id="text-12-2">
<p>
According the definition, anonymous class have access to the <a href="#org9221c00">lang.java.feat.access-level-modifiers</a> protected method of the superclass. Because the protected level members allow to be call from the subclass.
</p>

<p>
This is an example from spring of accessing to the protected method of another package.
</p>

<div class="org-src-container">
<pre class="src src-java">HttpMessageConverters&#65306;

    <span style="color: #9A93E1;">private</span> <span style="color: #A8CE93;">List</span>&lt;<span style="color: #A8CE93;">HttpMessageConverter</span>&lt;?&gt;&gt; getDefaultConverters() {
        <span style="color: #A8CE93;">List</span>&lt;<span style="color: #A8CE93;">HttpMessageConverter</span>&lt;?&gt;&gt; <span style="color: #DF8C8C;">converters</span> = <span style="color: #9A93E1;">new</span> <span style="color: #A8CE93;">ArrayList</span>&lt;&gt;();
        <span style="color: #9A93E1;">if</span> (ClassUtils.isPresent(<span style="color: #7FC1CA;">"org.springframework.web.servlet.config.annotation."</span> + <span style="color: #7FC1CA;">"WebMvcConfigurationSupport"</span>, <span style="color: #7FC1CA;">null</span>)) {

            <span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#21311;&#21517;&#20869;&#37096;&#31867;&#30340;&#23454;&#29616;</span>
            converters.addAll(<span style="color: #9A93E1;">new</span> <span style="color: #A8CE93;">WebMvcConfigurationSupport</span>() {
                <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">List</span>&lt;<span style="color: #A8CE93;">HttpMessageConverter</span>&lt;?&gt;&gt; <span style="color: #83AFE5;">defaultMessageConverters</span>() {
                    <span style="color: #9A93E1;">return</span> <span style="color: #9A93E1;">super</span>.getMessageConverters();
                }
            }.defaultMessageConverters());
        } <span style="color: #9A93E1;">else</span> {
            converters.addAll(<span style="color: #9A93E1;">new</span> <span style="color: #A8CE93;">RestTemplate</span>().getMessageConverters());
        }
        reorderXmlConvertersToEnd(converters);
        <span style="color: #9A93E1;">return</span> converters;
    }


</pre>
</div>

<div class="org-src-container">
<pre class="src src-java">            converters.addAll(<span style="color: #9A93E1;">new</span> <span style="color: #A8CE93;">WebMvcConfigurationSupport</span>() {
                <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">List</span>&lt;<span style="color: #A8CE93;">HttpMessageConverter</span>&lt;?&gt;&gt; <span style="color: #83AFE5;">defaultMessageConverters</span>() {
                    <span style="color: #9A93E1;">return</span> <span style="color: #9A93E1;">super</span>.getMessageConverters();
                }
            }.defaultMessageConverters());

</pre>
</div>

<p>
The <code>addAll</code> using a anonymous class to call the protected method <code>getMessageConverters()</code> of WebMvcConfigurationSupport.
</p>
</div>
</div>
<div id="outline-container-orgd9fd6a4" class="outline-3">
<h3 id="orgd9fd6a4"><span class="section-number-3">12.3.</span> Use Cases</h3>
<div class="outline-text-3" id="text-12-3">
<p>
Use for implementing the methods of a interface, which passes the method implementation as a virtual parameter to a method.
</p>
</div>
</div>
<div id="outline-container-org4272b93" class="outline-3">
<h3 id="org4272b93"><span class="section-number-3">12.4.</span> <a href="#org90ba124">lang.java.feat.lambda</a> simplifcation-lambda-expression</h3>
<div class="outline-text-3" id="text-12-4">
<p>
<a href="#org90ba124">lang.java.feat.lambda</a> is just a more simple grammar to ease the code of the anonymous class usage.
</p>
</div>
</div>

<div id="outline-container-orgc080d59" class="outline-3">
<h3 id="orgc080d59"><span class="section-number-3">12.5.</span> reference</h3>
<div class="outline-text-3" id="text-12-5">
<ul class="org-ul">
<li><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html">https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html</a>
Orcale Java turtorials</li>
<li><a href="https://fangshixiang.blog.csdn.net/article/details/80351540">https://fangshixiang.blog.csdn.net/article/details/80351540</a>
A blog introduces the usage of anonymouse classes.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org57b504d" class="outline-2">
<h2 id="org57b504d"><span class="section-number-2">13.</span> lang.java.feat.nested_class&#x2013;Way to group class to make code neatter</h2>
<div class="outline-text-2" id="text-13">
</div>

<div id="outline-container-org416d3db" class="outline-3">
<h3 id="org416d3db"><span class="section-number-3">13.1.</span> Why Use Nested Classes?</h3>
<div class="outline-text-3" id="text-13-1">
<blockquote>
<p>
Why Use Nested Classes?
</p>

<p>
Compelling reasons for using nested classes include the following:
</p>

<p>
It is a way of logically grouping classes that are only used in one place: If a class is useful to only one other class, then it is logical to embed it in that class and keep the two together. Nesting such &ldquo;helper classes&rdquo; makes their package more streamlined.
</p>

<p>
It increases encapsulation: Consider two top-level classes, A and B, where B needs access to members of A that would otherwise be declared private. By hiding class B within class A, A&rsquo;s members can be declared private and B can access them. In addition, B itself can be hidden from the outside world.
</p>

<p>
It can lead to more readable and maintainable code: Nesting small classes within top-level classes places the code closer to where it is used.
</p>

<p>
<a href="https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html">https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html</a>
</p>
</blockquote>

<p>
Divided into two categories: non-static and static, the precede one defined in instance level, which can access to the all fields in the outer class, while the succeesor one only can access the static value of the outerclass.
</p>

<ul class="org-ul">
<li>`static class` 和 `static final class` 都表示嵌套类（nested class）的一种形式。
<ul class="org-ul">
<li>`static class` 表示静态嵌套类，是指在外部类中定义的静态内部类。静态内部类不依赖于外部类的实例，可以直接通过外部类名称访问。静态内部类可以拥有静态成员和非静态成员。</li>
<li>`static final class` 表示静态常量内部类，是指被声明为静态和最终（不可更改）的嵌套类。静态常量内部类通常用于提供只读的常量或者枚举值，并且这些值在整个应用程序中都保持不变。</li>
<li>总结来说，`static class` 是表示静态嵌套类，而 `static final class` 是表示静态常量内部类。它们的区别在于是否为最终（final）类型以及是否用于表示常量值。
<a href="../../main/20240715224009--brochure_java_constant_class_way_to_hold_constant_value.html#ID-81dec664-08b5-4766-963a-689c8e42bfcc">brochure.java.constant-class</a> 静态内部类用于定义常量类的例子。</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org9ac8788" class="outline-2">
<h2 id="org9ac8788"><span class="section-number-2">14.</span> lang.java.feat.static_nested_class&#x2013;As the same as top-level class but nested</h2>
<div class="outline-text-2" id="text-14">
<p>
Treated as a top-level class, is independent with the outerclass, but has a more related semantics. That is say, a static nested class has access to the private static variable of the outer class while other top-level class can&rsquo;t do.
</p>

<p>
Use it when manifest the semantics that only can access by outer class to get a better cohesion rather than using a class file to contain the new class.
</p>

<p>
For example, to define a linked list node only use by the linked list can use the static calss.
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">class</span> <span style="color: #A8CE93;">MyLinkedList</span>&lt;<span style="color: #A8CE93;">E</span>&gt; {
    <span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#34394;&#25311;&#22836;&#23614;&#33410;&#28857;</span>
    <span style="color: #9A93E1;">final</span> <span style="color: #9A93E1;">private</span> <span style="color: #A8CE93;">Node</span>&lt;<span style="color: #A8CE93;">E</span>&gt; <span style="color: #DF8C8C;">head</span>, <span style="color: #DF8C8C;">tail</span>;
    <span style="color: #9A93E1;">private</span> <span style="color: #A8CE93;">int</span> <span style="color: #DF8C8C;">size</span>;

    <span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#21452;&#38142;&#34920;&#33410;&#28857;</span>
    <span style="color: #9A93E1;">private</span> <span style="color: #9A93E1;">static</span> <span style="color: #9A93E1;">class</span> <span style="color: #A8CE93;">Node</span>&lt;<span style="color: #A8CE93;">E</span>&gt; {
        <span style="color: #A8CE93;">E</span> <span style="color: #DF8C8C;">val</span>;
        <span style="color: #A8CE93;">Node</span>&lt;<span style="color: #A8CE93;">E</span>&gt; <span style="color: #DF8C8C;">next</span>;
        <span style="color: #A8CE93;">Node</span>&lt;<span style="color: #A8CE93;">E</span>&gt; <span style="color: #DF8C8C;">prev</span>;

        Node(E val) {
            <span style="color: #9A93E1;">this</span>.val = val;
        }
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org1f16459" class="outline-2">
<h2 id="org1f16459"><span class="section-number-2">15.</span> lang.java.feat.interface&#x2013;Define behavior of code but no implementation</h2>
<div class="outline-text-2" id="text-15">
<blockquote>
<p>
In the Java programming language, an interface is a reference type, similar to a class, that can contain only constants, method signatures, default methods, static methods, and nested types. Method bodies exist only for default methods and static methods. Interfaces cannot be instantiated—they can only be implemented by classes or extended by other interfaces.
</p>

<p>
&#x2013; <a href="https://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html">https://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html</a>
</p>
</blockquote>

<p>
Java Interface 在设计角度，是一种规范（Contract）。其规定了实现该 Interface 的「类」应该具备哪些行为（接口中的方法），即这个类能做些什么。但是！并不规定「类」该如何做。一个滥俗的例子：
</p>


<div class="org-src-container">
<pre class="src src-java"><span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">interface</span> <span style="color: #A8CE93;">Animal</span>{
    <span style="color: #A8CE93;">int</span> <span style="color: #DF8C8C;">age</span>=<span style="color: #7FC1CA; font-weight: bold;">1</span>; <span style="color: #899BA6;">// </span><span style="color: #899BA6;">-&gt; &#32534;&#35793;&#21518;&#20462;&#39280;&#31526;&#20026; public static final</span>
    <span style="color: #A8CE93;">String</span> <span style="color: #DF8C8C;">name</span> = <span style="color: #7FC1CA;">"babalala"</span>;
    <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">eat</span>(); <span style="color: #899BA6;">// </span><span style="color: #899BA6;">-&gt; &#32534;&#35793;&#21518;&#20462;&#39280;&#31526;&#20026; public abstract</span>
    <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">sleep</span>();
}

<span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">class</span> <span style="color: #A8CE93;">monkey</span> <span style="color: #9A93E1;">implements</span> <span style="color: #A8CE93;">Animal</span>{
    <span style="color: #7FC1CA;">@Override</span>
    <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">eat</span>(){
        <span style="color: #899BA6;">// </span><span style="color: #899BA6;">eat banana</span>
    }
    <span style="color: #7FC1CA;">@Override</span>
    <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">sleep</span>(){
        <span style="color: #899BA6;">// </span><span style="color: #899BA6;">sleep on the tree</span>
    }
}
</pre>
</div>

<p>
这个接口规定了，实现了 <code>interface Animal</code> 的类，必须有 <code>eat()</code> ， <code>sleep()</code> ，的行为。但是！怎么吃和睡，由实现类来决定。比如，猴子吃香蕉，猫吃鱼。
</p>

<p>
这个例子说明，规范中隐含着对代码行为的抽象。比如将，猫吃，狗吃，大象吃，抽象为动物吃。在这个例子中，动物的概念是抽象的，而猫，狗，大象对应着动物的一种具体形态。 <b>接口规范一些特定的行为，而不包含如何进行这些行为，即接口中的方法没有具体的方法实现</b> 。抽象在 interface 的语法层面中表现为，interface 会被 <code>abstract</code> 修饰（隐藏的，编译后自动加的）。这意味着 interface 和 <a href="#org6aa7135">lang.java.feat.abstract-class</a> 一样不能被实例化。
</p>

<p>
一致的是，接口中的方法是没有 <code>{}</code> 的。因为 <code>{}</code> 表示方法体。这表示什么呢？这意味着，接口中的方法也是抽象的，不包含具体定义。在 <b>没有</b> <code>default</code> 或 <code>static</code> 修饰的方法，都隐含着 abstract 修饰符，指示着接口实现类必须重写该方法。而对于接口中的变量，默认是 <code>static final</code> 的，也就是静态，即不可变的，必须在定义时指定变量值。
</p>

<p>
那规范和抽象还能意味着什么？或说怎么理解，接口变量都是常量，接口方法要么具有默认实现（Java 8 后， <code>default</code> 修饰方法，即可编写方法体），要么就是 <code>static</code> 修饰的？
</p>

<p>
<b>规范和抽象还隐含着无状态</b> 。
</p>

<p>
通常一个 class 可以被实例化，所以拥有属于实例自身的状态（实例变量），以及有具体实现的方法。因为接口不定义具体实现，所以其应该和具体的状态无关。这样做会带来什么好处呢？ <a href="#orgc027445">lang.java.oop.feat.polymorphism</a> 「 <b>多态</b> 」！
</p>

<p>
Java 接口是可以被多实现的。接口在 Java 类型系统中，是一个引用类型。对于实现了接口的具体类（实现意味着定义行为的具体实现），就具备这组行为的具体实现。对于 Animal 接口，Monkey 类和 Cat 类都实现了这个 Animal，意味着它们遵循着 Animal 的规范，具有吃和睡觉的行为。当我编写一个方法，方法参数是 Animal 类型，并在方法中调用 Animal 的 <code>eat()</code> 方法，这会出现什么效果呢？
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#39282;&#20859;&#21592;&#21890;&#20859;&#21160;&#29289;</span>
<span style="color: #9A93E1;">public</span> feed(Animal animal){
    animal.eat();
    <span style="color: #899BA6;">// </span><span style="color: #899BA6;">then animal.sleep(); or do something else</span>
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #A8CE93;">Monkey</span> <span style="color: #DF8C8C;">monkey</span> = <span style="color: #9A93E1;">new</span> <span style="color: #A8CE93;">Monkey</span>();
<span style="color: #A8CE93;">Cat</span> <span style="color: #DF8C8C;">cat</span> = <span style="color: #9A93E1;">new</span> <span style="color: #A8CE93;">Cat</span>();
feed(monkey);
feed(cat);
</pre>
</div>

<p>
Animal 「变态」了！
</p>

<p>
<code>feed(Animal animal)</code> 方法的行为，随着传入的实现类型不同，而发生了改变。相比于为猴子，猫各写一个喂食方法，比如 <code>feedCat()</code>, <code>feedMonkey()</code> ，一个 <code>feed(Animal)</code> 实现了对于不同类型却具备相同抽象（即都能做什么）的方法整合，即方法的抽象。在符合一致抽象的情况下，面向抽象编程。
</p>

<p>
在 <code>feed</code> 方法中，相当于针对引用类型 <code>Animal</code> 制定了一套通用的控制逻辑，即喂动物。具体怎么喂，则由调用 feed 方法的使用者决定。面向抽象编程的一个含义是，将代码的执行逻辑推迟，交给调用者决定应该执行什么具体逻辑。这体现了，所谓的开闭原则：「 <b>对具体执行逻辑的扩展保持开放，对控制逻辑的修改保持封闭</b> 」。也就是说， <code>feed(Animal animal)</code> 是一套非具体过程，面向抽象的「控制逻辑」。其对兼容更多种类动物的实现保持开放。比如定义一个 <code>class dog implements Animal</code> ， <code>feed(Animal animal)</code> 就享受了新的扩展性，而无需更改面向抽象的逻辑。反过来，当需要修改面向抽象的逻辑时，比如动物吃完，去玩，而不是睡觉了，那所有实现了接口 Animal 的类，都可以获得这份改变。从这个例子可以知道，面向抽象编程，通过将代码中不变的逻辑抽取，降低代码的复杂度，并提高了代码的可维护性。
</p>

<p>
可以发现，多态的出现，是为了让不同的代码逻辑从相似的代码中抽离出来，并延迟了计算结果，即当将如何计算交给调用者，而不是耦合于代码之中。延迟计算的层次越高，则代码会越抽象，也就越稳定，越可维护。可以再过分点，将具体调用 <code>feed(Animal)</code> 能传什么动物，储存为一个 <code>HashMap&lt;String, Animal&gt; animalTypeMap</code> ，将具体的代码逻辑抽象化成了一个动物名称，根据动物名称选择 feed 应该表现出什么的结果。至于选什么，就交给程序的用户，想看饲养员喂什么动物了。当，动物园想要添加一些新动物的时候，比如狮子。饲养员喂动物的流程无需改变，只需要增加一个狮子实现类 <code>class Lion implements Animal</code> ，并且在 <code>animalTypeMap</code> 中添加动物类型和 <code>Lion</code> ，就完成了对动物园业务的扩展，而无需改变饲养员喂养动物的大体流程（先吃，后睡，再玩）。再比如，餐馆点单程序，面向抽象的订单编程，而不是对每一道菜编程。可以用一套代码控制点菜的流程，即所有菜品共用的代码，而不是为白切鸡，红烧肉，糖醋里脊分别写一个点菜方法控制点菜的流程。
</p>
</div>
</div>

<div id="outline-container-org6aa7135" class="outline-2">
<h2 id="org6aa7135"><span class="section-number-2">16.</span> lang.java.feat.abstract_class&#x2013;Mechanism between Class and Interface</h2>
<div class="outline-text-2" id="text-16">
<p>
abstract 修饰符用于修饰类和方法。abstract 表达的语义是：1）修饰类，表示类不能被实例化，需要被继承；2）修饰方法，表示方法需要被实现，即重写。
</p>

<blockquote>
<p>
An abstract class is a class that is declared abstract—it may or may not include abstract methods. Abstract classes cannot be instantiated, but they can be subclassed.
</p>

<p>
An abstract method is a method that is declared without an implementation (without braces, and followed by a semicolon), like this:
</p>

<p>
abstract void moveTo(double deltaX, double deltaY);
</p>

<p>
If a class includes abstract methods, then the class itself must be declared abstract, as in:
</p>

<p>
public abstract class GraphicObject {
   <i>/ declare fields
   /</i> declare nonabstract methods
   abstract void draw();
}
</p>

<p>
When an abstract class is subclassed, the subclass usually provides implementations for all of the abstract methods in its parent class. However, if it does not, then the subclass must also be declared abstract.
</p>

<p>
<a href="https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html">https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html</a>
</p>
</blockquote>

<p>
如果按照 abstract 所表达的语义，相比于 <a href="#org1f16459">lang.java.feat.interface</a> （Interface 也是默认 abstract 修饰的），为什么需要抽象类呢？
</p>

<p>
可以从是否具有「状态」来理解接口和抽象类的区别。
</p>

<p>
<b>接口的一大特点是「无状态」</b> 。接口内的变量是 <code>public static final</code> ，不可变的。其不像具体类的实例，可以拥有实例变量，储存实例状态。 <b>抽象类可以具有实例状态，并其实例变量可以被子类所共享</b> 。另外，抽象类可以部分抽象，包含对实例变量操作的共同方法的默认实现，即子类需要实现抽象类中的 abstract 方法，且可以选择重写抽象类中的默认实现方法，并且这些方法可以做 <a href="#org9221c00">lang.java.feat.access-level-modifiers</a> 全范围的权限限制，而接口的方法和变量均为 public。
</p>

<p>
abstract class 作为 concrete class 和 Interface 的中间地带，即可以定义规范，也可以含有带状态的默认实现。可以发现抽象类和普通类的区别在于：多了 abstract 修饰方法的能力，并且不能被实例化而已。
</p>

<table>


<colgroup>
<col  class="org-center">

<col  class="org-center">

<col  class="org-center">

<col  class="org-center">
</colgroup>
<tbody>
<tr>
<td class="org-center">对比</td>
<td class="org-center">普通类</td>
<td class="org-center">抽象类</td>
<td class="org-center">接口</td>
</tr>

<tr>
<td class="org-center">可见权限范围-变量</td>
<td class="org-center">无限制</td>
<td class="org-center">无限制</td>
<td class="org-center">only <code>public static final</code></td>
</tr>

<tr>
<td class="org-center">可见权限范围-方法</td>
<td class="org-center">无限制</td>
<td class="org-center">无限制</td>
<td class="org-center">only <code>public</code> also <code>abstract</code></td>
</tr>

<tr>
<td class="org-center">abstract 方法</td>
<td class="org-center">X</td>
<td class="org-center">√</td>
<td class="org-center">√</td>
</tr>

<tr>
<td class="org-center">构造方法</td>
<td class="org-center">√</td>
<td class="org-center">构造子类时会调用</td>
<td class="org-center">X</td>
</tr>

<tr>
<td class="org-center">实例方法</td>
<td class="org-center">√</td>
<td class="org-center">√</td>
<td class="org-center">default 修饰（实现类可以重写）</td>
</tr>

<tr>
<td class="org-center">static 方法</td>
<td class="org-center">√</td>
<td class="org-center">√</td>
<td class="org-center">X</td>
</tr>

<tr>
<td class="org-center">static blocks</td>
<td class="org-center">√</td>
<td class="org-center">√</td>
<td class="org-center">X</td>
</tr>
</tbody>
</table>

<p>
应该如何使用 abstract class 呢？设想一个场景，如果 100 个类需要实现一个相同的接口方法，并且实现是一致的，该怎么办呢？
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">interface</span> <span style="color: #A8CE93;">InterfaceWith100Implementions</span>{
    <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">ImplememtedBy100Class</span>();
}
</pre>
</div>

<p>
从 Java 8 开始，可以使用 <code>default</code> 关键字定义接口方法的默认实现。如果这 100 个子类想遵循接口定义的规范，并且想共享一些实例变量，并在共有的方法使用这些变量，该怎么办呢？这时候抽象类就派上了用场。
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">abstract</span> <span style="color: #9A93E1;">class</span> <span style="color: #A8CE93;">SharedBy100Class</span> <span style="color: #9A93E1;">implements</span> <span style="color: #A8CE93;">InterfaceWith100Implementions</span>{
    <span style="color: #9A93E1;">private</span> <span style="color: #A8CE93;">int</span> <span style="color: #DF8C8C;">commonInstanceVariable</span>;

    <span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#21487;&#20197;&#26377;&#20004;&#31181;&#23545;&#25509;&#21475;&#26041;&#27861;&#23454;&#29616;&#30340;&#36873;&#25321;</span>
    <span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#20004;&#32773;&#22312;&#20351;&#29992;&#20013;&#19981;&#20849;&#23384;&#65292;&#22240;&#20026;&#26041;&#27861;&#23450;&#20041;&#20914;&#31361;&#65292;&#36825;&#37324;&#20030;&#20010;&#20363;&#23376;&#35828;&#26126;&#12290;</span>
    <span style="color: #899BA6;">// </span><span style="color: #899BA6;">1) &#30041;&#20010;&#23376;&#31867;&#23454;&#29616;</span>
    <span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">abstract</span> <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">ImplememtedBy100Class</span>();

    <span style="color: #899BA6;">// </span><span style="color: #899BA6;">2) &#25552;&#20379;&#40664;&#35748;&#23454;&#29616;</span>
    <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">ImplememtedBy100Class</span>();

    <span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#20351;&#29992;&#23454;&#20363;&#21464;&#37327;&#30340;&#23454;&#20363;&#26041;&#27861; &#20351;&#29992; protected &#20462;&#39280;&#34920;&#31034;&#26041;&#27861;&#30340;&#21487;&#35265;&#33539;&#22260;&#25511;&#21046;&#22312;&#32487;&#25215;&#38142;&#20013;&#12290;</span>
    <span style="color: #9A93E1;">protected</span> <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">useCommonInstanceVariable</span>(){
        commonInstanceVariable = <span style="color: #7FC1CA; font-weight: bold;">1</span>;
        system.out.println(commonInstanceVariable);
    }

}
</pre>
</div>

<p>
在 java.util 包中，许多集合实现所遵循的模式是，使用 interface 定义规范，并使用 abstract class 提供部分的默认实现，具体的实现类，既继承了 abstract class 又通过声明实现规范 interface，以显化隐式的实现。比如，HashMap 就是一个很好的例子。HashMap 继承了抽象类 AbstractMap 并实现了 Map 接口。
</p>
</div>

<div id="outline-container-org4bed151" class="outline-3">
<h3 id="org4bed151"><span class="section-number-3">16.1.</span> abstract-template-pattern</h3>
<div class="outline-text-3" id="text-16-1">
<ul class="org-ul">
<li>含抽象方法：不提供默认实现，希望子类重写</li>
<li>不含抽象方法：不希望被实例化，仅仅是提供一个模板。因为默认实现可以被覆盖，运行时执行实现类的逻辑。</li>
</ul>

<p>
抽象类和模板模式的使用
  比如 HttpServlet 的 Service 根据请求类型，提供一个处理请求的模板，doGet() 只是提供一个占位，具体实现还是需要被子类来实现的。
</p>

<blockquote>
<p>
父类把能写的逻辑都写完，把不确定的业务代码抽成一个方法，调用它。当子类重写该方法，整个业务代码就活了。这就是模板方法模式
</p>
</blockquote>

<p>
这里使用了模板方法。
<a href="#org9221c00">lang.java.rule.access-level-modifiers</a> <code>protected</code> 关键字在工具包中定义方法，调用方需要继承该类，才能使用该方法 <a href="#org3e5b81a">lang.java.feat.anonymous-class.access-to-protected-method-in-other-package</a>
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">abstract</span> <span style="color: #9A93E1;">class</span> <span style="color: #A8CE93;">HttpServlet</span> <span style="color: #9A93E1;">extends</span> <span style="color: #A8CE93;">GenericServlet</span> {
<span style="color: #899BA6;">//</span><span style="color: #899BA6;">&#20854;&#20182;&#26041;&#27861;&#19982;&#25104;&#21592;&#21464;&#37327;&#65292;&#30053;...</span>
    service(<span style="color: #A8CE93;">ServletRequest</span> <span style="color: #DF8C8C;">req</span>, ServletReponse res) {
        <span style="color: #A8CE93;">HttpServletRequest</span> <span style="color: #DF8C8C;">request</span> = (<span style="color: #A8CE93;">HttpServletRequest</span>) req;
        <span style="color: #A8CE93;">HttpServletResponse</span> <span style="color: #DF8C8C;">response</span> =(<span style="color: #A8CE93;">HttpServletResponse</span>)res;
        service(request, response);
    }
    <span style="color: #9A93E1;">protected</span> <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">service</span>(<span style="color: #A8CE93;">HttpServletRequest</span> <span style="color: #DF8C8C;">req</span>, <span style="color: #A8CE93;">HttpServletResponse</span> <span style="color: #DF8C8C;">resp</span>) {
        <span style="color: #A8CE93;">String</span> <span style="color: #DF8C8C;">method</span> = req.getMethod();
        <span style="color: #9A93E1;">if</span>(<span style="color: #A8CE93;">METHOD</span> <span style="color: #83AFE5;">GET.equals</span>(<span style="color: #A8CE93;">method</span>)){
            <span style="color: #899BA6;">//</span><span style="color: #899BA6;">&#26412;&#26469;&#19994;&#21153;&#36923;&#36753;&#24212;&#35813;&#30452;&#25509;&#20889;&#22312;&#36825;&#65292;&#20294;&#26159;&#29238;&#31867;&#26080;&#27861;&#30693;&#36947;&#23376;&#31867;&#20855;&#20307;&#19994;&#21153;&#36923;&#36753;</span>
            doGet(req, resp);
        } <span style="color: #9A93E1;">else</span> <span style="color: #9A93E1;">if</span> (...) {
            ...
        } <span style="color: #9A93E1;">else</span> <span style="color: #9A93E1;">if</span> ...
    }
    <span style="color: #9A93E1;">protected</span> <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">doGet</span>(<span style="color: #A8CE93;">HttpServletRequest</span> <span style="color: #DF8C8C;">req</span>, <span style="color: #A8CE93;">HttpServletResponse</span> <span style="color: #DF8C8C;">res</span>) {
        <span style="color: #899BA6;">//</span><span style="color: #899BA6;">&#40664;&#35748;&#23454;&#29616;&#65292;&#21521;&#39029;&#38754;&#36755;&#20986; :405&#65292;http.get method not supported//&#36825;&#31181;&#23454;&#29616;&#26159;&#27809;&#26377;&#24847;&#20041;&#30340;&#65292;&#25152;&#20197;&#23376;&#31867;&#24517;&#39035;&#33267;&#23569;&#37325;&#20889;7&#20010;doxxx0&#20013;&#30340;&#19968;&#20010;&#65292;&#29992;&#20110;&#22788;&#29702;&#29305;&#23450;&#35831;&#27714;</span>
    }
    <span style="color: #899BA6;">//</span><span style="color: #899BA6;">&#20854;&#23427;&#20845;&#20010;doXxx0&#26041;&#27861;...</span>
}
</pre>
</div>

<p>
只需要继承 HttpServlet 实现 doGet()，doPost()，请求的处理逻辑，Tomcat 就会处理请求和响应的接收和发送。
</p>
</div>
</div>
<div id="outline-container-org744f3ad" class="outline-3">
<h3 id="org744f3ad"><span class="section-number-3">16.2.</span> Reference</h3>
<div class="outline-text-3" id="text-16-2">
<ul class="org-ul">
<li><a href="https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html">https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html</a></li>
<li>bravo 1988 (2022) servlet的本质以及如何工作. Available at: <a href="https://www.zhihu.com/question/21416727">https://www.zhihu.com/question/21416727</a> (Accessed: 25 April 2022).</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgb090c13" class="outline-2">
<h2 id="orgb090c13"><span class="section-number-2">17.</span> lang.java.feat.dynamic_proxy&#x2013;Mechanism to append feature to existed code</h2>
<div class="outline-text-2" id="text-17">
<p>
动态代理的使用场景是：
</p>
<ol class="org-ol">
<li>给一组实现了共同接口的对象，添加额外的功能，其特点是，只需要编写一次代码，将被代理的对象，传入编写好的动态代理函数即可；</li>
<li>Spring AOP，面向切面编程
核心是动态创建代理对象继承目标对象，通过目标对象持有代理对象调用目标对象的方法。</li>
</ol>

<p>
理解动态代理的前提：
</p>

<ol class="org-ol">
<li><a href="#org8132509">Java 对象（Object）</a>；</li>
<li><a href="#orgf4d0365">Java 类的生命周期</a>；</li>
<li><a href="#org2bdf07f">Java 反射（Reflection）</a>；</li>
<li><a href="#org254fad8">面向对象编程</a> 之接口实现多态。</li>
</ol>

<p>
动态代理核心的思想：用接口 T 创建 Class&lt;T&gt; 对象，即实例化接口返回一个代理对象。通过将被代理对象（后续称为——目标对象）作为参数传入，在代理对象中通过反射执行目标对象的方法，并添加额外的功能。
</p>

<p>
动态代理的具体实现，依靠 <code>java.lang.reflect.Proxy</code> 类和功能接口 <code>java.lang.reflect.InvocationHandler</code> 实现。
</p>

<p>
首先得了解反射是如何创建一个对象的实例的：
</p>

<p>
通过 <a href="#org2bdf07f">Java 反射（Reflection）</a> 创建一个对象的流程是：1) 获取描述对象 T 的 Class&lt;T&gt; 对象；2) 通过 Class&lt;T&gt; 对象获取 T 对象的构造器；3) 使用 <code>newInstance</code> 创建对象 T 的实例。
</p>

<p>
因为接口无法创建实例的，=Proxy= 类可以通过接收*一组接口*和类加载器返回一组 <code>Class&lt;T&gt;</code> 对象。该 <code>Class&lt;T&gt;</code> 对象为代理对象添加了一个 <code>class T(InvocationHandler.class)</code> 的构造方法。则反射实例化代理对象时需要传入一个功能接口 <code>InvocationHandler</code> 并实现 <code>invoke</code> 方法。
</p>

<p>
<code>Invoke(Object proxy, Method method, Object[] args)</code> 就是代理方法，通过在该方法中，创建目标对象，执行目标对象的方法，并添加额外的功能包装，完成动态代理的实现。
</p>

<p>
Proxy 类主要提供两个方法获取接口 <code>T</code> 的 <code>Class&lt;T&gt;</code> 对象：
</p>

<ol class="org-ol">
<li><code>getProxyClass(ClassLoader, Interfaces)</code> 直接返回一个描述对象 <code>T</code> 的 <code>Class&lt;T&gt;</code> 对象；</li>
<li><code>newProxyInstance(ClassLoader, Interfaces, InvocationHandler)=，其包含获取 =Class&lt;T&gt;</code> 对象以及通过 <code>Class&lt;T&gt;</code> 实例化代理对象的步骤。</li>
</ol>


<div class="org-src-container">
<pre class="src src-java"><span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">class</span> <span style="color: #A8CE93;">DynamicProxy</span>{
    <span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">static</span> <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">main</span>(<span style="color: #A8CE93;">String</span> <span style="color: #DF8C8C;">args</span>[]) <span style="color: #9A93E1;">throws</span> <span style="color: #A8CE93;">Throwable</span>{
        <span style="color: #A8CE93;">CalculatorImpl</span> <span style="color: #DF8C8C;">target</span> = <span style="color: #9A93E1;">new</span> <span style="color: #A8CE93;">CalculatorImpl</span>();
        <span style="color: #A8CE93;">Calculator</span> <span style="color: #DF8C8C;">calculatorProxy</span> = (<span style="color: #A8CE93;">Calculator</span>) getProxy(target); <span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#22810;&#24577;&#65292;&#29992;&#25509;&#21475;&#25345;&#26377;&#23454;&#29616;&#31867;&#23545;&#35937;&#65292;&#19981;&#31649; target &#26159;&#20160;&#20040;&#23454;&#29616;&#31867;&#37117;&#33021;&#20256;&#20837;&#21040;&#20195;&#29702;&#31867;&#20013;&#65307;</span>
        calculatorProxy.add(<span style="color: #7FC1CA; font-weight: bold;">1</span>, <span style="color: #7FC1CA; font-weight: bold;">2</span>);
        calculatorProxy.subtract(<span style="color: #7FC1CA; font-weight: bold;">2</span>, <span style="color: #7FC1CA; font-weight: bold;">1</span>);
    }

    <span style="color: #9A93E1;">private</span> <span style="color: #9A93E1;">static</span> <span style="color: #A8CE93;">Object</span> <span style="color: #83AFE5;">getProxy</span>(<span style="color: #9A93E1;">final</span> <span style="color: #A8CE93;">Object</span> <span style="color: #DF8C8C;">target</span>) <span style="color: #9A93E1;">throws</span> <span style="color: #A8CE93;">Exception</span>{
        <span style="color: #A8CE93;">Object</span> <span style="color: #DF8C8C;">proxy</span> =
            Porxy.newProxyInstance(target.getClass().getClassLoader(),
                                    target.getClass().getInterfaces(),
                                    (proxy, method, args) -&gt; {
                                        <span style="color: #A8CE93;">print</span> <span style="color: #DF8C8C;">log1</span>;
                                        <span style="color: #A8CE93;">Object</span> <span style="color: #DF8C8C;">result</span> = method.invoke(target, args);
                                        <span style="color: #A8CE93;">print</span> <span style="color: #DF8C8C;">log2</span>;
                                        <span style="color: #9A93E1;">return</span> result;});
        <span style="color: #9A93E1;">return</span> proxy;
    }
</pre>
</div>
</div>
</div>
<div id="outline-container-org90ba124" class="outline-2">
<h2 id="org90ba124"><span class="section-number-2">18.</span> lang.java.feat.lambda&#x2013;Syntactic sugar of anonymous class</h2>
<div class="outline-text-2" id="text-18">
<p>
lambda 是 <a href="20230726T105636--functional-programming.html#ID-25d86cb3-abb6-4a1f-b4f2-e49e1bf9bae4">functional-programming.concept.higher-order-function</a> 的一个特性。
</p>

<p>
这需要从传递函数开始说起。在过程语言中，如 C/C++ ，通过函数指针可以将函数 A 作为参数在函数 B 中传递。在 Java 中，没有方法指针，所以使用接口来传递方法。在 C/C++ 中，作为参数的函数被称为「回调函数」。去他的术语，只需要明白函数或方法在不同的语言中，传递机制是怎样的即可。
</p>

<blockquote>
<p>
The callback function in Java works in the following manner:
</p>

<ol class="org-ol">
<li>Create an interface X having a single method A().</li>
<li>Create a method method1() with A as a method parameter.</li>
<li>Call the A() method inside of the method1().</li>
<li>For calling method1(), we pass the instance of X and override the A().</li>
<li>Use arrow notation as an alternative to keyword news so that the code is clear.</li>
</ol>

<p>
from: <a href="https://www.javatpoint.com/java-callback-function">https://www.javatpoint.com/java-callback-function</a>
</p>
</blockquote>

<p>
Lambda 表达式是一个 <code>匿名方法</code> ，在 Java 中用于简化传递方法的语法。即在方法中传递「功能接口的实现」。功能接口中的抽象方法，定义了匿名方法的「形参类型」与「返回值」。
</p>

<p>
功能接口可以被理解为方法的规范。
</p>

<p>
在没有 Lambda 表达式前，需要通过使用匿名类的方式传递功能接口，即在参数中创建一个匿名类并且覆写功能接口中的抽象方法：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #899BA6;">// </span><span style="color: #899BA6;">Collections.sort(List list, Comparator&lt;T&gt;)</span>
Collections.sort(<span style="color: #A8CE93;">listOfMovies</span>, <span style="color: #9A93E1;">new</span> <span style="color: #A8CE93;">Comparator</span>&lt;<span style="color: #A8CE93;">Movie</span>&gt;() {
    <span style="color: #7FC1CA;">@Override</span>
    <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">int</span> <span style="color: #83AFE5;">compare</span>(<span style="color: #A8CE93;">Movie</span> <span style="color: #DF8C8C;">o1</span>, <span style="color: #A8CE93;">Movie</span> <span style="color: #DF8C8C;">o2</span>) {
    <span style="color: #9A93E1;">return</span> o1.getMovieName().compareTo(o2.getMovieName());
    }
});
</pre>
</div>

<p>
如果使用 Lambda 表达式，则上面的语法可以简化为：
</p>

<div class="org-src-container">
<pre class="src src-java">Collection.sort(<span style="color: #A8CE93;">listOfMovies</span>, (o1, o2) -&gt; o1.getMovieName().compareTo(o2.getMovieName()));
</pre>
</div>

<p>
Lambda 表达式由三部分组成：「参数列表」-&gt; {「表达式」}。
</p>

<p>
在前面提到，Lambda 实质上是一个函数，则函数的参数类型和返回值根据功能接口定义来确定。
</p>

<p>
「参数列表」中的类型，可以省略，因为编译器可以根据功能接口的定义自动推断。‘{}’中的表达式，需要返回特定的类型，如果只有一条语句，可以省略‘{}’。
</p>

<p>
参考：
</p>
<ul class="org-ul">
<li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1305158055100449">LXF-Lambda 基础</a></li>
<li><a href="https://java2blog.com/lambda-expressions-in-java-8/">https://java2blog.com/lambda-expressions-in-java-8/</a></li>
</ul>
</div>

<div id="outline-container-org7da9abf" class="outline-3">
<h3 id="org7da9abf"><span class="section-number-3">18.1.</span> lang.java.feat.lambda.method-qoute</h3>
<div class="outline-text-3" id="text-18-1">
<p>
使用方法引用可以更加简洁地传递功能接口的实现。
</p>

<p>
引用语法： <code>类名::方法名</code>
</p>

<p>
引用的方法类型可以是，1) 静态方法，2) 实例方法，3) 构造方法
</p>

<p>
举例，静态方法：
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">class</span> <span style="color: #A8CE93;">Main</span> {
    <span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">static</span> <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">main</span>(<span style="color: #A8CE93;">String</span>[] <span style="color: #DF8C8C;">args</span>) {
        <span style="color: #A8CE93;">String</span>[] <span style="color: #DF8C8C;">array</span> = <span style="color: #9A93E1;">new</span> <span style="color: #A8CE93;">String</span>[] { <span style="color: #7FC1CA;">"Apple"</span>, <span style="color: #7FC1CA;">"Orange"</span>, <span style="color: #7FC1CA;">"Banana"</span>, <span style="color: #7FC1CA;">"Lemon"</span> };
        Arrays.sort(array, Main::cmp);
        System.out.println(String.join(<span style="color: #7FC1CA;">", "</span>, array));
    }

    <span style="color: #9A93E1;">static</span> <span style="color: #A8CE93;">int</span> <span style="color: #83AFE5;">cmp</span>(<span style="color: #A8CE93;">String</span> <span style="color: #DF8C8C;">s1</span>, <span style="color: #A8CE93;">String</span> <span style="color: #DF8C8C;">s2</span>) {
        <span style="color: #9A93E1;">return</span> s1.compareTo(s2);
    }
}
</pre>
</div>

<p>
构造方法的引用语法为：=类名::new=
</p>

<p>
需要注意的是： <b>方法引用只是功能接口实现的一种方式，传入的方法依然需要满足功能接口所规定的「参数类型」和「返回类型」</b> 。
</p>
</div>
</div>

<div id="outline-container-org8e1854f" class="outline-3">
<h3 id="org8e1854f"><span class="section-number-3">18.2.</span> Functional Interface</h3>
<div class="outline-text-3" id="text-18-2">
<p>
功能接口可以理解为函数的容器或包装。通过功能接口包装函数，达到在方法参数传递函数的目的。功能接口可以赋予，函数的惰性求值，即不到函数被使用的一刻都不会被执行。【这个理解是比较到位的，从功能性上考虑功能接口的作用】
</p>

<p>
功能接口是那些只包含「*单个抽象方法*」的接口。这就是说，功能接口除了包含「单个抽象方法」外，还可以包含 <code>default</code> 方法， <code>static</code> 方法和重写来自 java.lang.object 的方法。
</p>

<p>
一个单方法的功能接口：
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #7FC1CA;">@FunctionalInterface</span>
<span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">interface</span> <span style="color: #A8CE93;">Callable</span>&lt;<span style="color: #A8CE93;">V</span>&gt; {
    <span style="color: #A8CE93;">V</span> <span style="color: #83AFE5;">call</span>() <span style="color: #9A93E1;">throws</span> <span style="color: #A8CE93;">Exception</span>;
}
</pre>
</div>

<p>
一个包含其他方法的功能接口：
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #7FC1CA;">@FunctionalInterface</span>
<span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">interface</span> <span style="color: #A8CE93;">Comparator</span>&lt;<span style="color: #A8CE93;">T</span>&gt; {

    <span style="color: #A8CE93;">int</span> <span style="color: #83AFE5;">compare</span>(<span style="color: #A8CE93;">T</span> <span style="color: #DF8C8C;">o1</span>, <span style="color: #A8CE93;">T</span> <span style="color: #DF8C8C;">o2</span>);

    <span style="color: #A8CE93;">boolean</span> <span style="color: #83AFE5;">equals</span>(<span style="color: #A8CE93;">Object</span> <span style="color: #DF8C8C;">obj</span>);

    <span style="color: #9A93E1;">default</span> <span style="color: #A8CE93;">Comparator</span>&lt;<span style="color: #A8CE93;">T</span>&gt; <span style="color: #83AFE5;">reversed</span>() {
        <span style="color: #9A93E1;">return</span> Collections.reverseOrder(<span style="color: #9A93E1;">this</span>);
    }

    <span style="color: #9A93E1;">default</span> <span style="color: #A8CE93;">Comparator</span>&lt;<span style="color: #A8CE93;">T</span>&gt; <span style="color: #83AFE5;">thenComparing</span>(<span style="color: #A8CE93;">Comparator</span>&lt;? <span style="color: #9A93E1;">super</span> <span style="color: #A8CE93;">T</span>&gt; <span style="color: #DF8C8C;">other</span>) {
        ...
    }
    ...
}

</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org62a26e2" class="outline-2">
<h2 id="org62a26e2"><span class="section-number-2">19.</span> brochure.java.feat.optional&#x2013;Return-default-if-object-null</h2>
<div class="outline-text-2" id="text-19">
<p>
在 Java 8 中，你可以使用 `Optional` 来处理可能为空的值，并根据情况返回默认值。下面是一个示例，展示了如何使用 `Optional` 来实现这一功能：
</p>

<div class="org-src-container">
<pre class="src src-java">```java
<span style="color: #9A93E1;">import</span> <span style="color: #7FC1CA;">java</span>.<span style="color: #7FC1CA;">util</span>.<span style="color: #A8CE93;">Optional</span>;

<span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">class</span> <span style="color: #A8CE93;">OptionalExample</span> {
    <span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">static</span> <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">main</span>(<span style="color: #A8CE93;">String</span>[] <span style="color: #DF8C8C;">args</span>) {
        <span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#21019;&#24314;&#19968;&#20010; Optional &#23545;&#35937;&#65292;&#36825;&#37324;&#20551;&#35774;&#23427;&#21487;&#33021;&#20026;&#31354;</span>
        <span style="color: #A8CE93;">Optional</span>&lt;<span style="color: #A8CE93;">String</span>&gt; <span style="color: #DF8C8C;">optionalValue</span> = Optional.ofNullable(getNullableValue());

        <span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#22914;&#26524;&#20540;&#19981;&#20026;&#31354;&#65292;&#36820;&#22238;&#35813;&#20540;&#65307;&#21542;&#21017;&#36820;&#22238;&#40664;&#35748;&#20540;</span>
        <span style="color: #A8CE93;">String</span> <span style="color: #DF8C8C;">result</span> = optionalValue.orElse(<span style="color: #7FC1CA;">"&#40664;&#35748;&#20540;"</span>);

        System.out.println(<span style="color: #7FC1CA;">"&#32467;&#26524;: "</span> + result);
    }

    <span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">static</span> <span style="color: #A8CE93;">String</span> <span style="color: #83AFE5;">getNullableValue</span>() {
        <span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#22312;&#23454;&#38469;&#24773;&#20917;&#20013;&#65292;&#36825;&#20010;&#26041;&#27861;&#21487;&#33021;&#36820;&#22238;&#19968;&#20010;&#20540;&#65292;&#25110;&#32773;&#36820;&#22238; null</span>
        <span style="color: #9A93E1;">return</span> <span style="color: #7FC1CA;">"&#23454;&#38469;&#20540;"</span>; <span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#20551;&#35774;&#36825;&#37324;&#26377;&#19968;&#20010;&#23454;&#38469;&#20540;</span>
        <span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#22914;&#26524;&#27809;&#26377;&#23454;&#38469;&#20540;&#65292;&#21487;&#20197;&#36820;&#22238; null&#65292;Optional.ofNullable &#21487;&#20197;&#22788;&#29702; null &#20540;</span>
    }
}
```
</pre>
</div>

<p>
在上述示例中，`getNullableValue()` 方法模拟了一个可能返回值的场景，我们用 `Optional.ofNullable` 将它包装为 `Optional` 对象。然后，使用 `orElse` 方法来获取值，如果值为空，将会返回指定的默认值。
</p>

<p>
如果 `optionalValue` 包含一个非空值，那么 `result` 将会是实际值；如果 `optionalValue` 为空，`result` 将会是指定的默认值。
</p>

<p>
这种方式可以帮助你更加优雅地处理可能为空的情况，并提供一个合适的默认值。
</p>
</div>
</div>
<div id="outline-container-orgea5ea5c" class="outline-2">
<h2 id="orgea5ea5c"><span class="section-number-2">20.</span> lang.java.feat.stream.collectors</h2>
<div class="outline-text-2" id="text-20">
<p>
This operation use in <code>.collect()</code> to reduce the stream into a new collection, like <a href="../../main/20230619T105636--qujinja_wms.html#ID-bab0e0d0-934c-4466-bb71-eae1fc03f851">lang.java.data.collection.list</a>, map, set etc.
</p>

<blockquote>
<p>
Implementations of Collector that implement various useful reduction operations, such as accumulating elements into collections, summarizing elements according to various criteria, etc.
The following are examples of using the predefined collectors to perform common mutable reduction tasks:
</p>

<p>
Since 1.8
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-java"> <span style="color: #899BA6;">// </span><span style="color: #899BA6;">Accumulate names into a List</span>
 <span style="color: #A8CE93;">List</span>&lt;<span style="color: #A8CE93;">String</span>&gt; <span style="color: #DF8C8C;">list</span> = people.stream()
     .map(Person::getName)
     .collect(Collectors.toList());

 <span style="color: #899BA6;">// </span><span style="color: #899BA6;">Accumulate names into a TreeSet</span>
 <span style="color: #A8CE93;">Set</span>&lt;<span style="color: #A8CE93;">String</span>&gt; <span style="color: #DF8C8C;">set</span> = people.stream()
     .map(Person::getName)
     .collect(Collectors.toCollection(TreeSet::<span style="color: #9A93E1;">new</span>));

 <span style="color: #899BA6;">// </span><span style="color: #899BA6;">Convert elements to strings and concatenate them, separated by commas</span>
 <span style="color: #A8CE93;">String</span> <span style="color: #DF8C8C;">joined</span> = things.stream()
     .map(Object::toString)
     .collect(Collectors.joining(<span style="color: #7FC1CA;">","</span>));

 <span style="color: #899BA6;">// </span><span style="color: #899BA6;">Compute sum of salaries of employee</span>
 <span style="color: #A8CE93;">int</span> <span style="color: #DF8C8C;">total</span> = employees.stream()
     .collect(Collectors.summingInt(Employee::getSalary));

 <span style="color: #899BA6;">// </span><span style="color: #899BA6;">Group employees by department</span>
 <span style="color: #A8CE93;">Map</span>&lt;<span style="color: #A8CE93;">Department</span>, <span style="color: #A8CE93;">List</span>&lt;<span style="color: #A8CE93;">Employee</span>&gt;&gt; <span style="color: #DF8C8C;">byDept</span> = employees.stream()
     .collect(Collectors.groupingBy(Employee::getDepartment));

 <span style="color: #899BA6;">// </span><span style="color: #899BA6;">Compute sum of salaries by department</span>
 <span style="color: #A8CE93;">Map</span>&lt;<span style="color: #A8CE93;">Department</span>, <span style="color: #A8CE93;">Integer</span>&gt; <span style="color: #DF8C8C;">totalByDept</span> = employees.stream()
     .collect(Collectors.groupingBy(Employee::getDepartment, Collectors.summingInt(Employee::getSalary)));

 <span style="color: #899BA6;">// </span><span style="color: #899BA6;">Partition students into passing and failing</span>
 <span style="color: #A8CE93;">Map</span>&lt;<span style="color: #A8CE93;">Boolean</span>, <span style="color: #A8CE93;">List</span>&lt;<span style="color: #A8CE93;">Student</span>&gt;&gt; <span style="color: #DF8C8C;">passingFailing</span> = students.stream()
     .collect(Collectors.partitioningBy(s -&gt; s.getGrade() &gt;= PASS_THRESHOLD));

</pre>
</div>
</div>

<div id="outline-container-orge126796" class="outline-3">
<h3 id="orge126796"><span class="section-number-3">20.1.</span> brochure</h3>
<div class="outline-text-3" id="text-20-1">
<ul class="org-ul">
<li><a href="../../main/20230620T105636--ja_wms_notes.html#ID-702175ee-5734-496d-a235-7b9ac5de82a8">lang.java.brochure.stream.list2map</a></li>

<li><a href="../../main/20230620T105636--ja_wms_notes.html#ID-5b30d9af-cf4b-4f1d-99fe-497423a90eec">lang.java.brochure.stream.list2string</a></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org8adf261" class="outline-2">
<h2 id="org8adf261"><span class="section-number-2">21.</span> Reference</h2>
<div class="outline-text-2" id="text-21">
<style>.csl-entry{text-indent: -1.5em; margin-left: 1.5em;}</style><div class="csl-bib-body">
</div>
</div>
</div>
<div id="outline-container-orgcf3f5b8" class="outline-2">
<h2 id="orgcf3f5b8"><span class="section-number-2">22.</span> Update</h2>
</div>
<div class="taglist"><a href="https://oahnukuw.github.io/tags.html">Tags</a>: <a href="https://oahnukuw.github.io/tag-blog.java.html">blog.java</a> </div></div>
<div id="postamble" class="status"><center>
  <div class="footer-networks">
    <ul>
      <li>
	<a class="d-flex align-items-center" href="https://github.com/oahnukuw" rel="noreferrer">
          <svg class="footer-networks-icons"><use href="#github"></use></svg>
          <span class="social-name">GitHub</span>
	</a>
      </li>
    </ul>
  </div>
  <div class="copyright">
<a rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a><br /><span xmlns:dct="https://purl.org/dc/terms/" href="https://purl.org/dc/dcmitype/Text" property="dct:title" rel="dct:type">oahnukuw.github.io</span> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://oahnukuw.github.io" property="cc:attributionName" rel="cc:attributionURL">Oahnukuw</a> is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike 3.0 Unported License</a>.
  </div>
</center>
</div>
</body>
</html>
