<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title><![CDATA[Iterative]]></title>
<description><![CDATA[Iterative]]></description>
<link>https://oahnukuw.github.io/</link>
<lastBuildDate>Tue, 06 Aug 2024 18:44:15 +0800</lastBuildDate>
<item>
  <title><![CDATA[§Java Features That I Learned]]></title>
  <description><![CDATA[
<nav id="table-of-contents" role="doc-toc">
<h2> <a href="javascript:window.scrollTo(0,0)" style="color: black !important;" class="tooltip" title="Go to the top of the page">Ξ </a> </h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgd9e4476">1. programming.semantics</a></li>
<li><a href="#org0731022">2. lang.java.class.life-circle</a>
<ul>
<li><a href="#org68b126f">2.1. 加载：查找字节码文件并载入内存</a></li>
<li><a href="#org3c05680">2.2. 连接</a></li>
<li><a href="#org672bc69">2.3. 初始化</a></li>
<li><a href="#org18c2bdd">2.4. 卸载</a></li>
<li><a href="#org19b0f04">2.5. 参见：https://pdai.tech/md/java/jvm/java-jvm-classload.html</a></li>
</ul>
</li>
<li><a href="#org6575cdb">3. lang.java.concept.object&#x2013;abstraction of code</a>
<ul>
<li><a href="#org214b58d">3.1. equals-hashCode-override</a></li>
<li><a href="#org927c304">3.2. 参见：</a></li>
</ul>
</li>
<li><a href="#org1cd6382">4. lang.java.concept.classpath&#x2013;url to locate class</a>
<ul>
<li><a href="#org843585c">4.1. 方法参数传递</a></li>
<li><a href="#org02d5922">4.2. References</a></li>
</ul>
</li>
<li><a href="#org356edf0">5. lang.java.concept.object<sub>oriented</sub><sub>programming</sub>&#x2013;code abstraction base on object</a>
<ul>
<li><a href="#org84bc2b4">5.1. Encapsulation</a></li>
<li><a href="#org23354c4">5.2. Reference</a></li>
</ul>
</li>
<li><a href="#orgd3b49cf">6. lang.java.feat.inheritance&#x2013;Mechanism to reuse code (field-method)</a>
<ul>
<li><a href="#org65065a6">6.1. inheritance.method-call-priority</a></li>
</ul>
</li>
<li><a href="#org1afa784">7. lang.java.feat.polymorphism&#x2013;Mechanism-to-seperate-code</a>
<ul>
<li><a href="#orgc83fe72">7.1. 多态意味着面向抽象编程</a></li>
<li><a href="#org52c7bc0">7.2. polymorphism.example</a></li>
</ul>
</li>
<li><a href="#org46cd96e">8. lang.java.feat.auto<sub>boxing</sub>&#x2013;Box of basic data type</a></li>
<li><a href="#orgeb75c2b">9. lang.java.feat.reflection&#x2013;Mechanism to manipulate class</a>
<ul>
<li><a href="#org4e4417f">9.1. 获取「类」的 Class&lt;T&gt; 对象</a></li>
<li><a href="#orge9f14e4">9.2. 操作字段通过 Class&lt;T&gt; 中的 Field 相关方法</a></li>
<li><a href="#org1c6f92b">9.3. 操作方法通过 Class&lt;T&gt; 中的 Method 相关方法</a></li>
</ul>
</li>
<li><a href="#org74a66dc">10. lang.java.feat.access<sub>level</sub><sub>modifiers</sub>&#x2013;Mechanism to restrict scope of access</a>
<ul>
<li><a href="#org561b415">10.1. Reference</a></li>
</ul>
</li>
<li><a href="#orgc14983d">11. lang.java.feat.exception&#x2013;Mechanism to deal with error of code</a>
<ul>
<li><a href="#org410ed0b">11.1. lang.java.feat.exception.claim-to-catch</a></li>
<li><a href="#orgc288183">11.2. lang.java.feat.exception.type</a></li>
<li><a href="#org4f06c72">11.3. lang.java.feat.exception.throw-example</a></li>
</ul>
</li>
<li><a href="#org89dd9a6">12. lang.java.feat.anonymous<sub>class</sub>&#x2013;Mechanism to deliver interface to methods</a>
<ul>
<li><a href="#org25a2882">12.1. Definition</a></li>
<li><a href="#org053d832">12.2. Access to protected method in other package</a></li>
<li><a href="#org79a4c2b">12.3. Use Cases</a></li>
<li><a href="#orgce90bfc">12.4. lang.java.feat.lambda simplifcation-lambda-expression</a></li>
<li><a href="#org3a4c284">12.5. reference</a></li>
</ul>
</li>
<li><a href="#orga09fe16">13. lang.java.feat.nested<sub>class</sub>&#x2013;Way to group class to make code neatter</a>
<ul>
<li><a href="#org68ca4dc">13.1. Why Use Nested Classes?</a></li>
</ul>
</li>
<li><a href="#org7a325f0">14. lang.java.feat.static<sub>nested</sub><sub>class</sub>&#x2013;As the same as top-level class but nested</a></li>
<li><a href="#org7a89ec3">15. lang.java.feat.interface&#x2013;Define behavior of code but no implementation</a></li>
<li><a href="#orgc4b8bfb">16. lang.java.feat.abstract<sub>class</sub>&#x2013;Mechanism between Class and Interface</a>
<ul>
<li><a href="#org25c7e77">16.1. abstract-template-pattern</a></li>
<li><a href="#orgf759907">16.2. Reference</a></li>
</ul>
</li>
<li><a href="#orgddf7935">17. lang.java.feat.dynamic<sub>proxy</sub>&#x2013;Mechanism to append feature to existed code</a></li>
<li><a href="#org8da09fb">18. lang.java.feat.lambda&#x2013;Syntactic sugar of anonymous class</a>
<ul>
<li><a href="#orgb89d467">18.1. lang.java.feat.lambda.method-qoute</a></li>
<li><a href="#orgf4fd1c6">18.2. Functional Interface</a></li>
</ul>
</li>
<li><a href="#org103535f">19. brochure.java.feat.optional&#x2013;Return-default-if-object-null</a></li>
<li><a href="#org9c5938e">20. lang.java.feat.stream.collectors</a>
<ul>
<li><a href="#org439f0d5">20.1. brochure</a></li>
</ul>
</li>
<li><a href="#orgec3b4ea">21. Reference</a></li>
<li><a href="#orgb4272b3">22. Update</a></li>
</ul>
</div>
</nav>


<div id="outline-container-orgd9e4476" class="outline-2">
<h2 id="orgd9e4476"><span class="section-number-2">1.</span> programming.semantics</h2>
<div class="outline-text-2" id="text-1">
<blockquote>
<p>
Semantics in programming refers to the meaning or behavior associated with a piece of code. It encompasses how a programming construct behaves during execution, what it does, and how it interacts with other parts of the program. Semantics contrasts with syntax, which is the set of rules that define the structure and form of valid code.
</p>
</blockquote>

<p>
语义是理解程序的关键。语义指代代码在执行过程的行为，代码会做些什么，以及怎么做。
</p>

<p>
但理解程序的语义并不是一件简单的事情。在编程语言的角度，其基础是语法以及语言特性。
</p>

<p>
比如，一个<a href="#org7a89ec3">lang.java.feat.interface</a>关键字所蕴含的语义是非常丰富的。interface 的语义可以是一种「契约」（ contract ），体现的是实现该 interface 的 class 具备什么样的能力，「即能做什么」。另外，interface 还可以是实现多继承的机制，通过实现多个 interface ，一个 class可以具备不同类型的能力。除此之外，接口的多实现展现了多态。通过持有多态引用（polymorphic reference），可以获得具备多种实现的通用代码，即多态。
</p>

<p>
除了语言特性外，可能还需要具备软件设计的其他知识，比如设计模式，才能看懂蕴含设计模式的代码。
</p>
</div>
</div>

<div id="outline-container-org0731022" class="outline-2">
<h2 id="org0731022"><span class="section-number-2">2.</span> lang.java.class.life-circle</h2>
<div class="outline-text-2" id="text-2">
<p>
为了行文方便，后续简称「 Java 类」为「类」。
</p>

<p>
什么是 =Java Classes=？在定义一个「类」的时候，会看到：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #9A93E1;">class</span> <span style="color: #A8CE93;">Person</span>{
    ...
}
</pre>
</div>

<p>
<code>class</code> 语法关键字，定义一个「类」，即 <a href="#org6575cdb">Java 对象（ Object ）</a> 的模板。「类」的存在形式是什么？根据不同的存在形式，就有了「类」的生命周期。
</p>

<p>
在 Java 程序的视角下：1) 编写代码时，「类」以<code>.java</code>文件的形式是存储在硬盘中；2) 程序编译后，「类」以<code>.class</code>二进制文本的形式（字节码）存储于硬盘中；3) 程序运行时，「类」放置于 JVM 分配的内存中。
</p>

<p>
可以知道的是，虽然类存储的形式不同了，但是，表示的含义是一样的，即<code>描述 Java对象的数据结构，定义了对象的状态以及行为</code> 。
</p>

<p>
类的生命周期，特指在程序运行时，一个类会经历怎么样的生命历程？从被加载到内存（诞生）中，算是，到被使用（贡献价值）后，被卸载（死亡），一个类是如何走过她的一生呢？
</p>

<p>
类的生杀大权掌握在&ldquo;判官&rdquo; Java 虚拟机（ JVM ）手上。
</p>


<figure id="orgab63fb3">
<img src="atta_Java_类的生命周期/2022-07-05_16-08-09_screenshot.png" alt="2022-07-05_16-08-09_screenshot.png">

</figure>
</div>

<div id="outline-container-org68b126f" class="outline-3">
<h3 id="org68b126f"><span class="section-number-3">2.1.</span> 加载：查找字节码文件并载入内存</h3>
<div class="outline-text-3" id="text-2-1">
<p>
在程序编译后，JVM 首先需要根据唯一标识的类名找到<code>.class</code>文件，然后将文件中静态的数据结构，转换为 JVM 运行时所规范的数据结构，放入 JVM 内存的方法区中。并且根据数据结构生成一个<code>Class&lt;T&gt;</code>对象，放置于 JVM 内存的堆区。
</p>


<figure id="org967a6f2">
<img src="atta_Java_类的生命周期/2022-07-05_15-41-38_screenshot.png" alt="2022-07-05_15-41-38_screenshot.png">

</figure>


<figure id="org3316adb">
<img src="atta_Java_类的生命周期/2022-07-05_class_loader.png" alt="2022-07-05_class_loader.png">

</figure>
</div>
</div>

<div id="outline-container-org3c05680" class="outline-3">
<h3 id="org3c05680"><span class="section-number-3">2.2.</span> 连接</h3>
<div class="outline-text-3" id="text-2-2">
<ol class="org-ol">
<li>验证类的安全性；</li>
<li>为类的静态变量分配内存并初始化为 JVM 默认值。比如基本类型，整数为 0 ，引用型为 <code>null=，对于 =final static</code>修饰的常量则会被赋值（用户定义的值）后放入到常量池中；</li>
<li>替换符号引用，比如类名，字段，方法名等符号替换成类似 <code>0X21344</code> 全局唯一的引用标识
ps: 在 debug 中就能看到每个变量的全局标识。</li>
</ol>
</div>
</div>

<div id="outline-container-org672bc69" class="outline-3">
<h3 id="org672bc69"><span class="section-number-3">2.3.</span> 初始化</h3>
<div class="outline-text-3" id="text-2-3">
<p>
初始化类变量，为静态变量赋予用户定义的初值，初始化父类的方法等。
</p>

<blockquote>
<ul class="org-ul">
<li>创建类的实例，也就是 new 的方式</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射(如Class.forName(&ldquo;com.pdai.jvm.Test&rdquo;))</li>
<li>初始化某个类的子类，则其父类也会被初始化</li>
<li>Java虚拟机启动时被标明为启动类的类(Java Test)，直接使用java.exe命令来运行某个主类</li>
</ul>
</blockquote>
</div>
</div>

<div id="outline-container-org18c2bdd" class="outline-3">
<h3 id="org18c2bdd"><span class="section-number-3">2.4.</span> 卸载</h3>
<div class="outline-text-3" id="text-2-4">
<p>
在使用结束后，将类从 JVM 中卸载。其包括正常退出结束和异常结束导致卸载。
</p>
</div>
</div>

<div id="outline-container-org19b0f04" class="outline-3">
<h3 id="org19b0f04"><span class="section-number-3">2.5.</span> 参见：<a href="https://pdai.tech/md/java/jvm/java-jvm-classload.html">https://pdai.tech/md/java/jvm/java-jvm-classload.html</a></h3>
</div>
</div>
<div id="outline-container-org6575cdb" class="outline-2">
<h2 id="org6575cdb"><span class="section-number-2">3.</span> lang.java.concept.object&#x2013;abstraction of code</h2>
<div class="outline-text-2" id="text-3">
<p>
<code>Object</code> 在 Java 中是一种代码抽象的基本单位。抽象是<a href="#org356edf0">面向对象编程</a>的核心，其基础是现实世界到计算机世界中对象的映射。【这里的对象其实是理解现实世界的一种途径（颇有哲学意味的话题）。】
</p>

<p>
现实世界的实体具有「状态」和「行为」两种特征。比如狗有状态（名字，颜色，品种，饿了）和行为（吃，叫，摇尾巴）。通过「状态」和「行为」就可以大概模拟实体之间交互的过程了。比如，狗和狗打架，你养了一只狗。
</p>

<p>
<code>Object</code> 在 Java 中可以被理解为抽象数据类型。其中包含「字段」和「方法」，分别对应现实对象的「状态」和「行为」。
</p>

<p>
Java 使用 <code>class</code> 作为 Object 的模板，提供定义 Object 状态和方法的途径。通过对模板实例化得到一个具体的<code>Object~，也就是 ~class</code>实例（ instance ）。如何定义一个<code>Java class</code>呢？使用 <code>class</code> 关键字可以定义一个 =Java class=。
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #9A93E1;">class</span> <span style="color: #A8CE93;">Person</span>{
    ...
}
</pre>
</div>

<p>
之所以使用对象，是因为将代码以对象为单位抽象，提供了一些好处：
</p>

<p>
比如，代码模块化、利用封装屏蔽细节、代码复用、更容易的代码替换和修复代码漏洞。
</p>

<p>
总的来说，面向对象编程，提供了一种编程的视角。在这个视角下，对象是基本的操作单位。什么继承，多态就是在对象基础上高效构建软件工程的模式。比如，通过继承和多态可以减少冗余代码的编写。
</p>

<p>
<b>在学习 Java 对象的时候，可以从两种特征出发，迅速掌握该对象是什么。噢，还应该加上继承关系。</b>
</p>
</div>

<div id="outline-container-org214b58d" class="outline-3">
<h3 id="org214b58d"><span class="section-number-3">3.1.</span> equals-hashCode-override</h3>
<div class="outline-text-3" id="text-3-1">
<p>
这四个东西，在自定义对象的时候似乎有时需要覆写或传入（ Comparator ），有时似乎又不用。
</p>

<p>
equals() 是继承自老祖宗<code>Object~。所有的对象都继承自 ~Object~，所以所有对象都有一个默认对比对象 hash值的~equals()</code>方法。
</p>

<p>
todo: 补充其他方法的简介
</p>

<p>
为了解决何时需要使用这些东西，首先需要先确立这些方法或接口的使用场景。即，它们何时被需要。频繁使用的场景是「集合类」。
</p>

<p>
场景 1：当需要利用对象中的状态判断是否相等的时候需要在定义类时覆写 ~equals()~。比如，判断列表里面是否包含某个对象。
</p>

<p>
场景 2 ：当需要为一个对象生成一个唯一标识的时候，比如 Map集合中，要确定唯一的键值（ key ）的时候。则 Map 中放入的对象需要覆写hashCode()方法。如果实现的hashCode()生成对象的 hashCode 越唯一，Map 的查找效率就越高。
</p>

<p>
场景 3：当需要在列表中实现
</p>


<p>
如果要用一个 List 来存储你自定义的对象，那么，当要使用 List 中的<code>contains()</code>或 <code>indexOf()~，那么就必须实现。因为这些方法利用~equals</code>方法来判定对象是否相等。
</p>

<p>
如何覆写呢？Java 的 equals 实现需要满足等价类的定义：自反、对称、传递和一致。
</p>

<p>
因此，我们总结一下equals()方法的正确编写方法：
</p>

<ol class="org-ol">
<li>先确定实例“相等”的逻辑，即哪些字段相等，就认为实例相等；</li>
<li>用 <code>instanceof</code> 判断传入的待比较的 Object 是不是当前类型，如果是，继续比较，否则，返回 ~false~；</li>
<li>对引用类型用<code>Objects.equals()</code>比较，对基本类型直接用==比较。</li>
</ol>

<p>
*使用<code>Objects.equals()</code>比较两个引用类型是否相等的目的是省去了判断 null 的麻烦。两个引用类型都是 null 时它们也是相等的*。
</p>

<p>
如果不调用 List 的 contains()、indexOf() 这些方法，那么放入的元素就不需要实现equals()方法。
</p>

<p>
参见：<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1265116446975264">编写 equals 方法</a>
</p>
</div>
</div>

<div id="outline-container-org927c304" class="outline-3">
<h3 id="org927c304"><span class="section-number-3">3.2.</span> 参见：</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li><a href="https://docs.oracle.com/javase/tutorial/java/concepts/object.html">https://docs.oracle.com/javase/tutorial/java/concepts/object.html</a></li>
<li><a href="https://en.wikipedia.org/wiki/Object-oriented_programming">https://en.wikipedia.org/wiki/Object-oriented_programming</a></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org1cd6382" class="outline-2">
<h2 id="org1cd6382"><span class="section-number-2">4.</span> lang.java.concept.classpath&#x2013;url to locate class</h2>
<div class="outline-text-2" id="text-4">
<blockquote>
<p>
首先你要知道 java 这个指令是作什麽用的？
<b>执行 java ，其实就是启动 JVM ，之后接下类别名称，表示由 JVM 载入该类别的.class并执行。</b>
</p>
</blockquote>

<p>
在理解 CLASSPATH 之前，需要先理解 Class 是什么。
</p>

<p>
Class 是字节码文件，Java 启动的过程就是，启动 Jvm 虚拟机然后加载.class文件执行。
</p>

<p>
CLASSPATH 其实就是告诉 Jvm 在哪里找到所需要的.class文件。
</p>

<p>
所以，用 Java 命令执行 Jar 压缩包里面的类时，需要使用-classpath(-cp)参数指定.class文件的位置。
</p>

<pre class="example">
java -cp target/my-app-1.0-SNAPSHOT.jar com.mycompany.app.App

</pre>
</div>

<div id="outline-container-org843585c" class="outline-3">
<h3 id="org843585c"><span class="section-number-3">4.1.</span> 方法参数传递</h3>
<div class="outline-text-3" id="text-4-1">
<ul class="org-ul">
<li>基本类型参数的传递，是调用方值的复制。双方各自的后续修改，互不影响。</li>
<li>引用类型参数的传递，调用方的变量，和接收方的参数变量，指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方（因为指向同一个对象嘛）。</li>
</ul>
</div>
</div>

<div id="outline-container-org02d5922" class="outline-3">
<h3 id="org02d5922"><span class="section-number-3">4.2.</span> References</h3>
<div class="outline-text-3" id="text-4-2">
<p>
良葛格(2014) CLASSPATH是什麼？, OPENHOME.CC. Available at: <a href="https://openhome.cc/Gossip/JavaEssence/WhatClasspath.html">https://openhome.cc/Gossip/JavaEssence/WhatClasspath.html</a> (Accessed: 2 March 2022).
</p>
</div>
</div>
</div>

<div id="outline-container-org356edf0" class="outline-2">
<h2 id="org356edf0"><span class="section-number-2">5.</span> lang.java.concept.object<sub>oriented</sub><sub>programming</sub>&#x2013;code abstraction base on object</h2>
<div class="outline-text-2" id="text-5">
<p>
面向对象是一种编程范式，以<a href="#org6575cdb">lang.java.object</a>为基本单位提供代码抽象的模式。
</p>

<p>
面向对象的核心是抽象。为了保证抽象这一特性，Java 提供封装、<a href="#orgd3b49cf">lang.java.feat.inheritance&#x2013;mechanism to reuse code (field-method)</a>和 <a href="#org1afa784">lang.java.feat.polymorphism&#x2013;mechanism-to-seperate-code</a>。
</p>
</div>
<div id="outline-container-org84bc2b4" class="outline-3">
<h3 id="org84bc2b4"><span class="section-number-3">5.1.</span> Encapsulation</h3>
<div class="outline-text-3" id="text-5-1">
<p>
一个典型的对象包含「状态」和「行为」，通过对象提供的行为（方法），可以改变对象内部的状态（字段）。以对象为基本单位编程，对外提供编写者希望暴露的方法，隐藏对象内部的实现细节。这就是封装。
</p>
</div>
</div>

<div id="outline-container-org23354c4" class="outline-3">
<h3 id="org23354c4"><span class="section-number-3">5.2.</span> Reference</h3>
<div class="outline-text-3" id="text-5-2">
<blockquote>
<p>
When you want to purchase a car, the car dealer gives you the details of
available colors, seating capacity, engine, gearbox, type of steering and other
kinds of general details. The car dealer never tells you specific (complex)
details of material being used for the hood, nuts and bolts and such.
abstraction car parts
</p>

<p>
The above details are not needed. These details are hidden by the car dealer.
Like this, you can think of other examples in the real world. Abstraction is
everywhere. - <a href="https://www.startertutorials.com/corejava/object-orientation-principles.html">startertutorials</a>
</p>
</blockquote>
</div>
</div>
</div>

<div id="outline-container-orgd3b49cf" class="outline-2">
<h2 id="orgd3b49cf"><span class="section-number-2">6.</span> lang.java.feat.inheritance&#x2013;Mechanism to reuse code (field-method)</h2>
<div class="outline-text-2" id="text-6">
<p>
假设在定义三个不同的类，它们拥有相同的 100 个属性，只有 3 个属性不同。如果每个类都需要写 100 个字段，这样会产生两倍的冗余代码，有什么办法可以解决呢？
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #9A93E1;">class</span> <span style="color: #A8CE93;">Person</span> {
    <span style="color: #9A93E1;">private</span> <span style="color: #A8CE93;">String</span> <span style="color: #DF8C8C;">name</span>;
    <span style="color: #9A93E1;">private</span> <span style="color: #A8CE93;">int</span> <span style="color: #DF8C8C;">age</span>;
    <span style="color: #899BA6;">//</span><span style="color: #899BA6;">... &#27492;&#22788;&#30465;&#30053;100&#20010;</span>

    <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">String</span> <span style="color: #83AFE5;">getName</span>() {...}
    <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">setName</span>(<span style="color: #A8CE93;">String</span> <span style="color: #DF8C8C;">name</span>) {...}
    <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">int</span> <span style="color: #83AFE5;">getAge</span>() {...}
    <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">setAge</span>(<span style="color: #A8CE93;">int</span> <span style="color: #DF8C8C;">age</span>) {...}
}
<span style="color: #9A93E1;">class</span> <span style="color: #A8CE93;">Student</span> {
    <span style="color: #9A93E1;">private</span> <span style="color: #A8CE93;">String</span> <span style="color: #DF8C8C;">name</span>;
    <span style="color: #9A93E1;">private</span> <span style="color: #A8CE93;">int</span> <span style="color: #DF8C8C;">age</span>;
    <span style="color: #899BA6;">//</span><span style="color: #899BA6;">... &#27492;&#22788;&#30465;&#30053;100&#20010;&#21644; Person &#30456;&#21516;&#30340;&#23646;&#24615;</span>
    <span style="color: #9A93E1;">private</span> <span style="color: #A8CE93;">int</span> <span style="color: #DF8C8C;">score</span>;

    <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">String</span> <span style="color: #83AFE5;">getName</span>() {...}
    <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">setName</span>(<span style="color: #A8CE93;">String</span> <span style="color: #DF8C8C;">name</span>) {...}
    <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">int</span> <span style="color: #83AFE5;">getAge</span>() {...}
    <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">setAge</span>(<span style="color: #A8CE93;">int</span> <span style="color: #DF8C8C;">age</span>) {...}
    <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">int</span> <span style="color: #83AFE5;">getScore</span>() { &#8230; }
    <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">setScore</span>(<span style="color: #A8CE93;">int</span> <span style="color: #DF8C8C;">score</span>) { &#8230; }
}
</pre>
</div>

<p>
在代码语义层面，继承提供了共同代码的抽取。比如，不同类间，相同的实例变量，一个方法的共同实现。将上述示例中，相同的字段提取到类 Person 中。类 Student 通过继承，就获得了 Person 中的所有实例变量了。
</p>

<p>
在对象逻辑层面，继承提供了 B 是 A 的抽象，比如 Student 是 Person，所以其在代码语义上共享属性和方法定义。
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #9A93E1;">class</span> <span style="color: #A8CE93;">Person</span> {
    <span style="color: #9A93E1;">private</span> <span style="color: #A8CE93;">String</span> <span style="color: #DF8C8C;">name</span>;
    <span style="color: #9A93E1;">private</span> <span style="color: #A8CE93;">int</span> <span style="color: #DF8C8C;">age</span>;
    <span style="color: #899BA6;">//</span><span style="color: #899BA6;">... &#27492;&#22788;&#30465;&#30053;100&#20010;&#20849;&#26377;&#23383;&#27573;</span>

    <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">String</span> <span style="color: #83AFE5;">getName</span>() {...}
    <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">setName</span>(<span style="color: #A8CE93;">String</span> <span style="color: #DF8C8C;">name</span>) {...}
    <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">int</span> <span style="color: #83AFE5;">getAge</span>() {...}
    <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">setAge</span>(<span style="color: #A8CE93;">int</span> <span style="color: #DF8C8C;">age</span>) {...}
}

<span style="color: #9A93E1;">class</span> <span style="color: #A8CE93;">Student</span> <span style="color: #9A93E1;">extends</span> <span style="color: #A8CE93;">Person</span> {
    <span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#19981;&#35201;&#37325;&#22797;name&#21644;age&#23383;&#27573;/&#26041;&#27861;,</span>
    <span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#21482;&#38656;&#35201;&#23450;&#20041;&#26032;&#22686;score&#23383;&#27573;/&#26041;&#27861;:</span>
    <span style="color: #9A93E1;">private</span> <span style="color: #A8CE93;">int</span> <span style="color: #DF8C8C;">score</span>;

    <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">int</span> <span style="color: #83AFE5;">getScore</span>() { &#8230; }
    <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">setScore</span>(<span style="color: #A8CE93;">int</span> <span style="color: #DF8C8C;">score</span>) { &#8230; }
}
</pre>
</div>
</div>

<div id="outline-container-org65065a6" class="outline-3">
<h3 id="org65065a6"><span class="section-number-3">6.1.</span> inheritance.method-call-priority</h3>
<div class="outline-text-3" id="text-6-1">
<blockquote>
<p>
首先我们先看一句话：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。这句话对多态进行了一个概括。其实在继承链中对象方法的调用存在一个优先级：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。
</p>

<p>
<a href="https://www.cnblogs.com/chenssy/p/3372798.html">https://www.cnblogs.com/chenssy/p/3372798.html</a>
</p>
</blockquote>

<p>
在调用对象的实例方法时，Java 编译器如何找到实际的调用方法呢？这里涉及到继承链的方法调用优先级。假设调用的方法是<code>show(object)</code>， <code>object</code> 是一个对象。 1 ）优先调用 this中的方法； 2 ）如果 this 中不存在<code>show(object)，则调用=super.show(object)</code>； 3 ）既然关于<code>show(object)</code>方法都不存在于继承链中，那么就尝试将参数 <code>object</code> 向上转型。再尝试调用<code>this.show((super)object)</code>。 4 ）如果 this 还是不存在关于<code>super.show(object)</code>的方法，则调用<code>super.show((super)object)</code>。既然编译器尝试向上寻找那么多次都没有办法找到方法，则判定方法未定义，编译错误。
</p>

<p>
在「引用类型和被引用类型」相同的情况下
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">class</span> <span style="color: #A8CE93;">Test</span> {
    <span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">static</span> <span style="color: #9A93E1;">class</span> <span style="color: #A8CE93;">Father</span>{
        <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">String</span> <span style="color: #83AFE5;">show</span>(<span style="color: #A8CE93;">Son</span> <span style="color: #DF8C8C;">obj</span>) {
            <span style="color: #9A93E1;">return</span> (<span style="color: #7FC1CA;">"Father show Son"</span>);
        }
        <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">String</span> <span style="color: #83AFE5;">show</span>(<span style="color: #A8CE93;">GrandSon</span> <span style="color: #DF8C8C;">obj</span>) {
            <span style="color: #9A93E1;">return</span> (<span style="color: #7FC1CA;">"Father show GrandSon"</span>);
        }
    }
    <span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">static</span> <span style="color: #9A93E1;">class</span> <span style="color: #A8CE93;">Son</span> <span style="color: #9A93E1;">extends</span> <span style="color: #A8CE93;">Father</span>{
        <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">String</span> <span style="color: #83AFE5;">show</span>(<span style="color: #A8CE93;">Son</span> <span style="color: #DF8C8C;">obj</span>) {
            <span style="color: #9A93E1;">return</span> (<span style="color: #7FC1CA;">"Son show Son"</span>);
        }
    }
    <span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">static</span> <span style="color: #9A93E1;">class</span> <span style="color: #A8CE93;">GrandSon</span> <span style="color: #9A93E1;">extends</span> <span style="color: #A8CE93;">Son</span>{
    }

    <span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">static</span> <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">main</span>(<span style="color: #A8CE93;">String</span>[] <span style="color: #DF8C8C;">args</span>) {
        <span style="color: #A8CE93;">Son</span> <span style="color: #DF8C8C;">son1</span> = <span style="color: #9A93E1;">new</span> <span style="color: #A8CE93;">Son</span>();
        <span style="color: #A8CE93;">GrandSon</span> <span style="color: #DF8C8C;">grandSon</span> = <span style="color: #9A93E1;">new</span> <span style="color: #A8CE93;">GrandSon</span>();
        <span style="color: #A8CE93;">Son</span> <span style="color: #DF8C8C;">son2</span> = <span style="color: #9A93E1;">new</span> <span style="color: #A8CE93;">Son</span>();

        System.out.println(<span style="color: #7FC1CA;">"1--"</span> + son1.show(son2));
        <span style="color: #899BA6;">// </span><span style="color: #899BA6;">-&gt; Son show Son</span>
        <span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#22240;&#20026; this &#25351;&#20195;&#30340;&#26159; son1&#65292;this &#22312; Son &#31867;&#22411;&#20013;&#25214;&#21040;&#20102;&#23545;&#24212;&#30340;&#26041;&#27861;</span>
        <span style="color: #899BA6;">// </span><span style="color: #899BA6;">public String show(Son obj)</span>
        System.out.println(<span style="color: #7FC1CA;">"2--"</span> + son1.show(grandSon));
        <span style="color: #899BA6;">// </span><span style="color: #899BA6;">-&gt; Father show GrandSon</span>
        <span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#22240;&#20026; this &#25351;&#20195;&#30340;&#26159; son1&#65292;this &#22312; Son &#31867;&#22411;&#20013;&#25214;&#19981;&#21040;&#23545;&#24212;&#30340;&#26041;&#27861;&#65292;&#25152;&#20197;&#32534;&#35793;&#22120;&#20250;&#21521;&#20854;&#29238;&#31867;&#23547;&#25214;&#26159;&#21542;&#26377; public String show(GrandSon obj) &#26041;&#27861;&#12290;&#22312;&#29238;&#31867;&#20013;&#25214;&#21040;&#65292;&#25152;&#20197;&#35843;&#29992; super.show(grandSon)</span>
    }
}
</pre>
</div>

<p>
这一继承链优先级同样适用于「被引用类型是引用类型的子类」的情况，即多态调用的情况。
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">class</span> <span style="color: #A8CE93;">TestPolymorphism</span> {
    <span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">static</span> <span style="color: #9A93E1;">class</span> <span style="color: #A8CE93;">A</span> {
        <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">String</span> <span style="color: #83AFE5;">show</span>(<span style="color: #A8CE93;">D</span> <span style="color: #DF8C8C;">obj</span>) {
            <span style="color: #9A93E1;">return</span> (<span style="color: #7FC1CA;">"A and D"</span>);
        }
        <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">String</span> <span style="color: #83AFE5;">show</span>(<span style="color: #A8CE93;">A</span> <span style="color: #DF8C8C;">obj</span>) {
            <span style="color: #9A93E1;">return</span> (<span style="color: #7FC1CA;">"A and A"</span>);
        }
        <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">String</span> <span style="color: #83AFE5;">show</span>(<span style="color: #A8CE93;">E</span> <span style="color: #DF8C8C;">obj</span>) {
            <span style="color: #9A93E1;">return</span> (<span style="color: #7FC1CA;">"A and E"</span>);
        }
    }

    <span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">static</span> <span style="color: #9A93E1;">class</span> <span style="color: #A8CE93;">B</span> <span style="color: #9A93E1;">extends</span> <span style="color: #A8CE93;">A</span> {
        <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">String</span> <span style="color: #83AFE5;">show</span>(<span style="color: #A8CE93;">B</span> <span style="color: #DF8C8C;">obj</span>) {
            <span style="color: #9A93E1;">return</span> (<span style="color: #7FC1CA;">"B and B"</span>);
        }
        <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">String</span> <span style="color: #83AFE5;">show</span>(<span style="color: #A8CE93;">A</span> <span style="color: #DF8C8C;">obj</span>) {
            <span style="color: #9A93E1;">return</span> (<span style="color: #7FC1CA;">"B and A"</span>);
        }
    }
    <span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">static</span> <span style="color: #9A93E1;">class</span> <span style="color: #A8CE93;">C</span> <span style="color: #9A93E1;">extends</span> <span style="color: #A8CE93;">B</span> { }
    <span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">static</span> <span style="color: #9A93E1;">class</span> <span style="color: #A8CE93;">D</span> <span style="color: #9A93E1;">extends</span> <span style="color: #A8CE93;">B</span> { }
    <span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">static</span> <span style="color: #9A93E1;">class</span> <span style="color: #A8CE93;">E</span> <span style="color: #9A93E1;">extends</span> <span style="color: #A8CE93;">A</span>{ }

    <span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">static</span> <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">main</span>(<span style="color: #A8CE93;">String</span>[] <span style="color: #DF8C8C;">args</span>) {
        <span style="color: #A8CE93;">A</span> <span style="color: #DF8C8C;">a1</span> = <span style="color: #9A93E1;">new</span> <span style="color: #A8CE93;">A</span>();
        <span style="color: #A8CE93;">A</span> <span style="color: #DF8C8C;">a2</span> = <span style="color: #9A93E1;">new</span> <span style="color: #A8CE93;">B</span>();
        <span style="color: #A8CE93;">B</span> <span style="color: #DF8C8C;">b</span> = <span style="color: #9A93E1;">new</span> <span style="color: #A8CE93;">B</span>();
        <span style="color: #A8CE93;">C</span> <span style="color: #DF8C8C;">c</span> = <span style="color: #9A93E1;">new</span> <span style="color: #A8CE93;">C</span>();
        <span style="color: #A8CE93;">D</span> <span style="color: #DF8C8C;">d</span> = <span style="color: #9A93E1;">new</span> <span style="color: #A8CE93;">D</span>();
        <span style="color: #A8CE93;">E</span> <span style="color: #DF8C8C;">e</span> = <span style="color: #9A93E1;">new</span> <span style="color: #A8CE93;">E</span>();

        System.out.println(<span style="color: #7FC1CA;">"1--"</span> + a1.show(b)); <span style="color: #899BA6;">// </span><span style="color: #899BA6;">this &#30340;&#31867;&#22411;&#20026; A&#65292;&#20248;&#20808;&#31867; A &#30340;&#26041;&#27861;&#65292;&#20294;&#19981;&#20250;&#21521;&#23376;&#31867;&#23547;&#25214;&#65292;&#38500;&#38750;&#23376;&#31867;&#23454;&#29616;&#20102;&#31867; A &#23450;&#20041;&#30340;&#26041;&#27861;&#12290;</span>
        System.out.println(<span style="color: #7FC1CA;">"2--"</span> + a1.show(c));
        System.out.println(<span style="color: #7FC1CA;">"3--"</span> + a1.show(d));
        System.out.println(<span style="color: #7FC1CA;">"4--"</span> + a2.show(b)); <span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#30001;&#20110;&#22810;&#24577;&#30340;&#21152;&#20837;&#65292;&#34987;&#24341;&#29992;&#31867;&#22411;&#20026; B&#12290;&#31532;&#19968;&#27425;&#23547;&#25214;&#65292;&#31867; A &#26159;&#21542;&#20855;&#26377; show(B obj) &#30340;&#26041;&#27861;&#65292;&#22914;&#26524;&#27809;&#26377;&#23601;&#21040; A &#30340;&#29238;&#31867;&#23547;&#25214;&#65292;&#20063;&#25214;&#19981;&#21040;&#65292;&#36827;&#34892;&#31532;&#19977;&#27493;&#23547;&#25214;&#65292;&#23558; b &#21521;&#19978;&#36716;&#22411;&#65292;&#30475;&#26159; this &#26159;&#21542;&#21547;&#26377; show(super(b)) &#30340;&#26041;&#27861;&#12290;&#25214;&#21040;&#20102; show(A obj)&#65292;&#21363;&#24471;&#21040; A and A &#30340;&#32467;&#26524;&#12290;</span>
        System.out.println(<span style="color: #7FC1CA;">"5--"</span> + a2.show(c));
        System.out.println(<span style="color: #7FC1CA;">"6--"</span> + a2.show(d));
        System.out.println(<span style="color: #7FC1CA;">"7--"</span> + b.show(b));
        System.out.println(<span style="color: #7FC1CA;">"8--"</span> + b.show(c));
        System.out.println(<span style="color: #7FC1CA;">"9--"</span> + b.show(d));
        System.out.println(<span style="color: #7FC1CA;">"10--"</span> + b.show(e));
    }
}

</pre>
</div>

<p>
所谓的多态就是，同样的状态，在不同的对象中以不同的形式展现，就是多态。
</p>

<p>
总的来说，通过封装、继承和多态，我们可以站在一种新的视角进行编程。相较于面向过程的编程范式，代码可以更加的独立，便于使用。
</p>
</div>
</div>
</div>
<div id="outline-container-org1afa784" class="outline-2">
<h2 id="org1afa784"><span class="section-number-2">7.</span> lang.java.feat.polymorphism&#x2013;Mechanism-to-seperate-code</h2>
<div class="outline-text-2" id="text-7">
<ul class="org-ul">
<li>子类可以覆写父类的方法（ Override ），覆写在子类中改变了父类方法的行为；</li>

<li>Java的方法调用总是作用于运行期对象的实际类型，这种行为称为多态；</li>
</ul>
</div>

<div id="outline-container-orgc83fe72" class="outline-3">
<h3 id="orgc83fe72"><span class="section-number-3">7.1.</span> 多态意味着面向抽象编程</h3>
<div class="outline-text-3" id="text-7-1">
<p>
抽象类设置一种规范，继承该抽象类的子类必须覆写其抽象方法。
</p>

<p>
<b>抽象类不可被实例化</b> 。
</p>

<p>
在使用方法时，使用抽象类作为参数，屏蔽了底层实现的多样性。
</p>

<p>
这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。
</p>

<p>
面向抽象编程的本质就是：
</p>

<p>
上层代码只定义规范（例如：abstract class Person）；
</p>

<p>
不需要子类就可以实现业务逻辑（正常编译），比如，定义只定义传入（接口的函数，只要实现了该接口的对象都可以传入）；
</p>

<p>
具体的业务逻辑由不同的子类实现，调用者并不关心。
</p>
</div>
</div>

<div id="outline-container-org52c7bc0" class="outline-3">
<h3 id="org52c7bc0"><span class="section-number-3">7.2.</span> polymorphism.example</h3>
<div class="outline-text-3" id="text-7-2">
<ol class="org-ol">
<li>使用集合接口接收实现了该接口的对象。接口越抽象，代码复用度和代码封装得越好。</li>
<li>使用迭代器（ Iterator ）遍历集合对象，集合们各自实现了高效的遍历方式，调用者使用迭代器不需要知道迭代器实现的细节。</li>
<li>设计模式 - 工厂和设计模式 - 策略 均运用了多态。通过持有抽象接口，接收实现类型而返回具体的实现。</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org46cd96e" class="outline-2">
<h2 id="org46cd96e"><span class="section-number-2">8.</span> lang.java.feat.auto<sub>boxing</sub>&#x2013;Box of basic data type</h2>
<div class="outline-text-2" id="text-8">
<p>
包装类是将基本变量类型用类包装起来。
</p>

<p>
看示例理解自动包装和拆包装。拆包装可以会出现个惊喜 <code>null</code> 。
</p>

<div class="org-src-container">
<pre class="src src-java" id="org67ee365"><span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">static</span> <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">main</span>(<span style="color: #A8CE93;">String</span>[] <span style="color: #DF8C8C;">args</span>) {
    <span style="color: #A8CE93;">int</span> <span style="color: #DF8C8C;">i</span> = <span style="color: #7FC1CA; font-weight: bold;">100</span>;
    <span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#36890;&#36807;new&#25805;&#20316;&#31526;&#21019;&#24314;Integer&#23454;&#20363;(&#19981;&#25512;&#33616;&#20351;&#29992;,&#20250;&#26377;&#32534;&#35793;&#35686;&#21578;):</span>
    <span style="color: #A8CE93;">Integer</span> <span style="color: #DF8C8C;">n1</span> = <span style="color: #9A93E1;">new</span> <span style="color: #A8CE93;">Integer</span>(i);
    <span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#36890;&#36807;&#38745;&#24577;&#26041;&#27861;valueOf(int)&#21019;&#24314;Integer&#23454;&#20363;:</span>
    <span style="color: #A8CE93;">Integer</span> <span style="color: #DF8C8C;">n2</span> = Integer.valueOf(i);
    <span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#36890;&#36807;&#38745;&#24577;&#26041;&#27861;valueOf(String)&#21019;&#24314;Integer&#23454;&#20363;:</span>
    <span style="color: #A8CE93;">Integer</span> <span style="color: #DF8C8C;">n3</span> = Integer.valueOf(<span style="color: #7FC1CA;">"100"</span>);
    System.out.println(n3.intValue());
    <span style="color: #A8CE93;">Integer</span> <span style="color: #DF8C8C;">n</span> = <span style="color: #7FC1CA; font-weight: bold;">100</span>; <span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#32534;&#35793;&#22120;&#33258;&#21160;&#20351;&#29992;Integer.valueOf(int) &#12304;&#33258;&#21160;&#35013;&#31665;&#12305;</span>
    <span style="color: #A8CE93;">int</span> <span style="color: #DF8C8C;">x</span> = n; <span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#32534;&#35793;&#22120;&#33258;&#21160;&#20351;&#29992;Integer.intValue() &#12304;&#33258;&#21160;&#25286;&#31665;&#65292;&#21487;&#33021;&#20250;&#23548;&#33268; null&#12305;</span>

}

</pre>
</div>

<pre class="example">
100
</pre>


<ul class="org-ul">
<li>int == Integer：均比较值的大小，Integer 会自动拆箱</li>
<li>Integer == Integer：会以 Integer 的形式比较，*比较对象的地址*
<ol class="org-ol">
<li>new 是一定返回一个新的对象</li>
<li>valueOf（静态工厂方法）在[-128，127]之内会返回同一缓存对象，超过此范围返回一个新对象。</li>
</ol></li>
<li>包装类是对象，所以需要使用 equals 进行判等</li>
</ul>
</div>
</div>

<div id="outline-container-orgeb75c2b" class="outline-2">
<h2 id="orgeb75c2b"><span class="section-number-2">9.</span> lang.java.feat.reflection&#x2013;Mechanism to manipulate class</h2>
<div class="outline-text-2" id="text-9">
<p>
在知道什么是反射前，需要了解一下 <a href="#org0731022">Java 类的生命周期</a>。
</p>

<p>
Java 程序的生命周期包括：编写、编译、运行（在 JVM 上运行字节码）。
</p>

<p>
反射能让 Java 程序在获取一个运行期间 <a href="#org6575cdb">Java 对象（ Object ）</a> 的所有信息。比如，字段和方法。
</p>

<p>
class 的生命周期包括加载、链接、初始化、使用和卸载。在程序运行期间，如果 JVM 需要使用到某个class A时，会加载类 A 。加载类 A时会创建一个<code>Class&lt;A&gt;</code>类来记录类 A 所有的信息。
</p>

<p>
通过 <code>Class</code> 类能获取类的信息和操作类的方法就是反射。简单来说就是使用 <code>Class</code> 类。
</p>

<p>
Java 通过java.lang.reflect包提供操纵 Class 对象的 API。
</p>
</div>

<div id="outline-container-org4e4417f" class="outline-3">
<h3 id="org4e4417f"><span class="section-number-3">9.1.</span> 获取「类」的 Class&lt;T&gt; 对象</h3>
<div class="outline-text-3" id="text-9-1">
<p>
方法一：直接通过一个 class 的静态变量 class 获取：
</p>

<p>
<code>Class cls = String.class;</code>
</p>

<p>
方法二：如果我们有一个实例变量，可以通过该实例变量提供的getClass()方法获取：
</p>

<p>
<code>String s = "Hello";</code>
<code>Class cls = s.getClass();</code>
</p>

<p>
方法三：如果知道一个 class 的完整类名，可以通过静态方法Class.forName()获取：
</p>

<p>
<code>Class cls = Class.forName("java.lang.String");</code>
</p>
</div>
</div>

<div id="outline-container-orge9f14e4" class="outline-3">
<h3 id="orge9f14e4"><span class="section-number-3">9.2.</span> 操作字段通过 Class&lt;T&gt; 中的 Field 相关方法</h3>
<div class="outline-text-3" id="text-9-2">
<p>
参见：<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1264803678201760">反射字段-lxf</a>
</p>
</div>
</div>

<div id="outline-container-org1c6f92b" class="outline-3">
<h3 id="org1c6f92b"><span class="section-number-3">9.3.</span> 操作方法通过 Class&lt;T&gt; 中的 Method 相关方法</h3>
<div class="outline-text-3" id="text-9-3">
<p>
参见：<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1264803678201760">反射方法-lxf</a>
</p>
</div>
</div>
</div>

<div id="outline-container-org74a66dc" class="outline-2">
<h2 id="org74a66dc"><span class="section-number-2">10.</span> lang.java.feat.access<sub>level</sub><sub>modifiers</sub>&#x2013;Mechanism to restrict scope of access</h2>
<div class="outline-text-2" id="text-10">
<p>
Java 使用<code>public~、~private~、~protected</code>和 <code>friendly</code> 对「变量」和「方法」的作用域进行限定。若代码没有使用访问修饰符时，默认作用域为 ~friendly~。
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">作用域</td>
<td class="org-left">当前类</td>
<td class="org-left">同一package</td>
<td class="org-left">子孙类</td>
<td class="org-left">其他package</td>
</tr>

<tr>
<td class="org-left">public</td>
<td class="org-left">√</td>
<td class="org-left">√</td>
<td class="org-left">√</td>
<td class="org-left">√</td>
</tr>

<tr>
<td class="org-left">protected</td>
<td class="org-left">√</td>
<td class="org-left">√</td>
<td class="org-left">√</td>
<td class="org-left">×</td>
</tr>

<tr>
<td class="org-left">friendly(default)</td>
<td class="org-left">√</td>
<td class="org-left">√</td>
<td class="org-left">×</td>
<td class="org-left">×</td>
</tr>

<tr>
<td class="org-left">private</td>
<td class="org-left">√</td>
<td class="org-left">×</td>
<td class="org-left">×</td>
<td class="org-left">×</td>
</tr>
</tbody>
</table>

<p>
作用域范围-&gt;变大。
</p>

<p>
For accessing to the protected method, one option is using <a href="#org053d832">lang.java.feat.anonymous-class.access-to-protected-method-in-other-package</a>
</p>
</div>

<div id="outline-container-org561b415" class="outline-3">
<h3 id="org561b415"><span class="section-number-3">10.1.</span> Reference</h3>
<div class="outline-text-3" id="text-10-1">
<ul class="org-ul">
<li><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html">Oracle Java Tutorials: Controlling Access to Members of a Class</a></li>
<li><blockquote>
<p>
只要记住了有 4 种访问权限， 4 个访问范围，然后将全选和范围在水平和垂直方向上分别按排从小到大或从大到小的顺序排列，就很容易画出上面的图了。——<a href="https://github.com/CoderLeixiaoshuai/java-eight-part/blob/master/docs/java/base/Java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A880%E9%97%AE.md#10%E4%BD%BF%E7%94%A8final%E5%85%B3%E9%94%AE%E5%AD%97%E4%BF%AE%E9%A5%B0%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E6%97%B6%E6%98%AF%E5%BC%95%E7%94%A8%E4%B8%8D%E8%83%BD%E5%8F%98%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%B8%8D%E8%83%BD%E5%8F%98">Java 基础入门 80 问</a>
</p>
</blockquote></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgc14983d" class="outline-2">
<h2 id="orgc14983d"><span class="section-number-2">11.</span> lang.java.feat.exception&#x2013;Mechanism to deal with error of code</h2>
<div class="outline-text-2" id="text-11">
</div>
<div id="outline-container-org410ed0b" class="outline-3">
<h3 id="org410ed0b"><span class="section-number-3">11.1.</span> lang.java.feat.exception.claim-to-catch</h3>
<div class="outline-text-3" id="text-11-1">
<p>
异常是一个类。Java 定义了一些常见的错误类型。当一个方法「 throw 」一个异常，则调用该方法时，需要在上层的调用栈中进行异常的捕获，否则代码会编译错误。
</p>
</div>
</div>

<div id="outline-container-orgc288183" class="outline-3">
<h3 id="orgc288183"><span class="section-number-3">11.2.</span> lang.java.feat.exception.type</h3>
<div class="outline-text-3" id="text-11-2">

<figure id="org691511e">
<img src="atta_java_基础/2022-03-10_20-09-39_screenshot.png" alt="2022-03-10_20-09-39_screenshot.png">

</figure>

<p>
所有异常继承 Throwable 。Error 和 Exception 是两种异常体系。
</p>

<p>
Error 为严重的错误，一般为关乎资源分配的问题，（如内存，栈等）导致程序无法运行。
</p>

<p>
Exception 分为运行时的错误和非运行时的错误。其中，非运行时的错误必须捕获。
</p>
</div>
</div>

<div id="outline-container-org4f06c72" class="outline-3">
<h3 id="org4f06c72"><span class="section-number-3">11.3.</span> lang.java.feat.exception.throw-example</h3>
<div class="outline-text-3" id="text-11-3">
<ol class="org-ol">
<li>创建 Exception 的实例。</li>
<li>使用 throw 抛出</li>
</ol>


<p>
<code>throw new NullPointerException();</code>
</p>

<p>
完成了上述两件事情，如果不用这样写，需要以下写法。
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">process2</span>(<span style="color: #A8CE93;">String</span> <span style="color: #DF8C8C;">s</span>) {
    <span style="color: #9A93E1;">if</span> (s==<span style="color: #7FC1CA;">null</span>) {
        <span style="color: #A8CE93;">NullPointerException</span> <span style="color: #DF8C8C;">e</span> = <span style="color: #9A93E1;">new</span> <span style="color: #A8CE93;">NullPointerException</span>();
        <span style="color: #9A93E1;">throw</span> e;
    }
}

</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org89dd9a6" class="outline-2">
<h2 id="org89dd9a6"><span class="section-number-2">12.</span> lang.java.feat.anonymous<sub>class</sub>&#x2013;Mechanism to deliver interface to methods</h2>
<div class="outline-text-2" id="text-12">
</div>
<div id="outline-container-org25a2882" class="outline-3">
<h3 id="org25a2882"><span class="section-number-3">12.1.</span> Definition</h3>
<div class="outline-text-3" id="text-12-1">
<p>
This code shows that creating an anonymous class means hoding an instance of an interface or an superclass as well as manifesting the abstraction oriented programming. That is to say, an anonymous class is the subtype of a class.
</p>

<blockquote>
<p>
HelloWorld frenchGreeting = new HelloWorld() {
    String name = &ldquo;tout le monde&rdquo;;
    public void greet() {
        greetSomeone(&ldquo;tout le monde&rdquo;);
    }
    public void greetSomeone(String someone) {
        name = someone;
        System.out.println(&ldquo;Salut &rdquo; + name);
    }
};
interface HelloWorld {
    public void greet();
    public void greetSomeone(String someone);
}
</p>
</blockquote>

<p>
An anonymous class use for implementing an interface or extending a class, which holds the true implementing of a method declaration.
</p>

<p>
An example of the difference of the definition between a normal local class and a anonymous class.
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">static</span> <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">main</span>(<span style="color: #A8CE93;">String</span>[] <span style="color: #DF8C8C;">args</span>) {
    <span style="color: #A8CE93;">HashMap</span>&lt;<span style="color: #A8CE93;">String</span>, <span style="color: #A8CE93;">String</span>&gt; <span style="color: #DF8C8C;">map1</span> = <span style="color: #9A93E1;">new</span> <span style="color: #A8CE93;">HashMap</span>&lt;&gt;();
    <span style="color: #A8CE93;">HashMap</span>&lt;<span style="color: #A8CE93;">String</span>, <span style="color: #A8CE93;">String</span>&gt; <span style="color: #DF8C8C;">map2</span> = <span style="color: #9A93E1;">new</span> <span style="color: #A8CE93;">HashMap</span>() {}; <span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#21311;&#21517;&#31867;!</span>
    <span style="color: #A8CE93;">HashMap</span>&lt;<span style="color: #A8CE93;">String</span>, <span style="color: #A8CE93;">String</span>&gt; <span style="color: #DF8C8C;">map3</span> = <span style="color: #9A93E1;">new</span> <span style="color: #A8CE93;">HashMap</span>() {
        {
            put(<span style="color: #7FC1CA;">"A"</span>, <span style="color: #7FC1CA;">"1"</span>);
            put(<span style="color: #7FC1CA;">"B"</span>, <span style="color: #7FC1CA;">"2"</span>);
        }
    };
    System.out.println(map1.getClass());
    System.out.println(map2.getClass());
    System.out.println(map3.getClass());
}

<span style="color: #899BA6;">/* </span><span style="color: #899BA6;">results:</span>
<span style="color: #899BA6;">    class java.util.HashMap</span>
<span style="color: #899BA6;">    class leetcode.editor.ds.TestInnerStaticClass$1</span>
<span style="color: #899BA6;">    class leetcode.editor.ds.TestInnerStaticClass$2</span>
<span style="color: #899BA6;">*/</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org053d832" class="outline-3">
<h3 id="org053d832"><span class="section-number-3">12.2.</span> Access to protected method in other package</h3>
<div class="outline-text-3" id="text-12-2">
<p>
According the definition, anonymous class have access to the <a href="#org74a66dc">lang.java.feat.access-level-modifiers</a> protected method of the superclass. Because the protected level members allow to be call from the subclass.
</p>

<p>
This is an example from spring of accessing to the protected method of another package.
</p>

<div class="org-src-container">
<pre class="src src-java">HttpMessageConverters&#65306;

    <span style="color: #9A93E1;">private</span> <span style="color: #A8CE93;">List</span>&lt;<span style="color: #A8CE93;">HttpMessageConverter</span>&lt;?&gt;&gt; getDefaultConverters() {
        <span style="color: #A8CE93;">List</span>&lt;<span style="color: #A8CE93;">HttpMessageConverter</span>&lt;?&gt;&gt; <span style="color: #DF8C8C;">converters</span> = <span style="color: #9A93E1;">new</span> <span style="color: #A8CE93;">ArrayList</span>&lt;&gt;();
        <span style="color: #9A93E1;">if</span> (ClassUtils.isPresent(<span style="color: #7FC1CA;">"org.springframework.web.servlet.config.annotation."</span> + <span style="color: #7FC1CA;">"WebMvcConfigurationSupport"</span>, <span style="color: #7FC1CA;">null</span>)) {

            <span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#21311;&#21517;&#20869;&#37096;&#31867;&#30340;&#23454;&#29616;</span>
            converters.addAll(<span style="color: #9A93E1;">new</span> <span style="color: #A8CE93;">WebMvcConfigurationSupport</span>() {
                <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">List</span>&lt;<span style="color: #A8CE93;">HttpMessageConverter</span>&lt;?&gt;&gt; <span style="color: #83AFE5;">defaultMessageConverters</span>() {
                    <span style="color: #9A93E1;">return</span> <span style="color: #9A93E1;">super</span>.getMessageConverters();
                }
            }.defaultMessageConverters());
        } <span style="color: #9A93E1;">else</span> {
            converters.addAll(<span style="color: #9A93E1;">new</span> <span style="color: #A8CE93;">RestTemplate</span>().getMessageConverters());
        }
        reorderXmlConvertersToEnd(converters);
        <span style="color: #9A93E1;">return</span> converters;
    }


</pre>
</div>

<div class="org-src-container">
<pre class="src src-java">            converters.addAll(<span style="color: #9A93E1;">new</span> <span style="color: #A8CE93;">WebMvcConfigurationSupport</span>() {
                <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">List</span>&lt;<span style="color: #A8CE93;">HttpMessageConverter</span>&lt;?&gt;&gt; <span style="color: #83AFE5;">defaultMessageConverters</span>() {
                    <span style="color: #9A93E1;">return</span> <span style="color: #9A93E1;">super</span>.getMessageConverters();
                }
            }.defaultMessageConverters());

</pre>
</div>

<p>
The <code>addAll</code> using a anonymous class to call the protected method <code>getMessageConverters()</code> of WebMvcConfigurationSupport.
</p>
</div>
</div>
<div id="outline-container-org79a4c2b" class="outline-3">
<h3 id="org79a4c2b"><span class="section-number-3">12.3.</span> Use Cases</h3>
<div class="outline-text-3" id="text-12-3">
<p>
Use for implementing the methods of a interface, which passes the method implementation as a virtual parameter to a method.
</p>
</div>
</div>
<div id="outline-container-orgce90bfc" class="outline-3">
<h3 id="orgce90bfc"><span class="section-number-3">12.4.</span> <a href="#org8da09fb">lang.java.feat.lambda</a> simplifcation-lambda-expression</h3>
<div class="outline-text-3" id="text-12-4">
<p>
<a href="#org8da09fb">lang.java.feat.lambda</a> is just a more simple grammar to ease the code of the anonymous class usage.
</p>
</div>
</div>

<div id="outline-container-org3a4c284" class="outline-3">
<h3 id="org3a4c284"><span class="section-number-3">12.5.</span> reference</h3>
<div class="outline-text-3" id="text-12-5">
<ul class="org-ul">
<li><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html">https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html</a>
Orcale Java turtorials</li>
<li><a href="https://fangshixiang.blog.csdn.net/article/details/80351540">https://fangshixiang.blog.csdn.net/article/details/80351540</a>
A blog introduces the usage of anonymouse classes.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orga09fe16" class="outline-2">
<h2 id="orga09fe16"><span class="section-number-2">13.</span> lang.java.feat.nested<sub>class</sub>&#x2013;Way to group class to make code neatter</h2>
<div class="outline-text-2" id="text-13">
</div>

<div id="outline-container-org68ca4dc" class="outline-3">
<h3 id="org68ca4dc"><span class="section-number-3">13.1.</span> Why Use Nested Classes?</h3>
<div class="outline-text-3" id="text-13-1">
<blockquote>
<p>
Why Use Nested Classes?
</p>

<p>
Compelling reasons for using nested classes include the following:
</p>

<p>
It is a way of logically grouping classes that are only used in one place: If a class is useful to only one other class, then it is logical to embed it in that class and keep the two together. Nesting such &ldquo;helper classes&rdquo; makes their package more streamlined.
</p>

<p>
It increases encapsulation: Consider two top-level classes, A and B, where B needs access to members of A that would otherwise be declared private. By hiding class B within class A, A&rsquo;s members can be declared private and B can access them. In addition, B itself can be hidden from the outside world.
</p>

<p>
It can lead to more readable and maintainable code: Nesting small classes within top-level classes places the code closer to where it is used.
</p>

<p>
<a href="https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html">https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html</a>
</p>
</blockquote>

<p>
Divided into two categories: non-static and static, the precede one defined in instance level, which can access to the all fields in the outer class, while the succeesor one only can access the static value of the outerclass.
</p>

<ul class="org-ul">
<li>`static class` 和`static final class`都表示嵌套类（nested class）的一种形式。
<ul class="org-ul">
<li>`static class` 表示静态嵌套类，是指在外部类中定义的静态内部类。静态内部类不依赖于外部类的实例，可以直接通过外部类名称访问。静态内部类可以拥有静态成员和非静态成员。</li>
<li>`static final class` 表示静态常量内部类，是指被声明为静态和最终（不可更改）的嵌套类。静态常量内部类通常用于提供只读的常量或者枚举值，并且这些值在整个应用程序中都保持不变。</li>
<li>总结来说，`static class` 是表示静态嵌套类，而`static final class`是表示静态常量内部类。它们的区别在于是否为最终（ final ）类型以及是否用于表示常量值。
<a href="../../main/20240715224009--brochure_java_constant_class_way_to_hold_constant_value.html#ID-81dec664-08b5-4766-963a-689c8e42bfcc">brochure.java.constant-class</a> 静态内部类用于定义常量类的例子。</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org7a325f0" class="outline-2">
<h2 id="org7a325f0"><span class="section-number-2">14.</span> lang.java.feat.static<sub>nested</sub><sub>class</sub>&#x2013;As the same as top-level class but nested</h2>
<div class="outline-text-2" id="text-14">
<p>
Treated as a top-level class, is independent with the outerclass, but has a more related semantics. That is say, a static nested class has access to the private static variable of the outer class while other top-level class can&rsquo;t do.
</p>

<p>
Use it when manifest the semantics that only can access by outer class to get a better cohesion rather than using a class file to contain the new class.
</p>

<p>
For example, to define a linked list node only use by the linked list can use the static calss.
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">class</span> <span style="color: #A8CE93;">MyLinkedList</span>&lt;<span style="color: #A8CE93;">E</span>&gt; {
    <span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#34394;&#25311;&#22836;&#23614;&#33410;&#28857;</span>
    <span style="color: #9A93E1;">final</span> <span style="color: #9A93E1;">private</span> <span style="color: #A8CE93;">Node</span>&lt;<span style="color: #A8CE93;">E</span>&gt; <span style="color: #DF8C8C;">head</span>, <span style="color: #DF8C8C;">tail</span>;
    <span style="color: #9A93E1;">private</span> <span style="color: #A8CE93;">int</span> <span style="color: #DF8C8C;">size</span>;

    <span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#21452;&#38142;&#34920;&#33410;&#28857;</span>
    <span style="color: #9A93E1;">private</span> <span style="color: #9A93E1;">static</span> <span style="color: #9A93E1;">class</span> <span style="color: #A8CE93;">Node</span>&lt;<span style="color: #A8CE93;">E</span>&gt; {
        <span style="color: #A8CE93;">E</span> <span style="color: #DF8C8C;">val</span>;
        <span style="color: #A8CE93;">Node</span>&lt;<span style="color: #A8CE93;">E</span>&gt; <span style="color: #DF8C8C;">next</span>;
        <span style="color: #A8CE93;">Node</span>&lt;<span style="color: #A8CE93;">E</span>&gt; <span style="color: #DF8C8C;">prev</span>;

        Node(E val) {
            <span style="color: #9A93E1;">this</span>.val = val;
        }
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org7a89ec3" class="outline-2">
<h2 id="org7a89ec3"><span class="section-number-2">15.</span> lang.java.feat.interface&#x2013;Define behavior of code but no implementation</h2>
<div class="outline-text-2" id="text-15">
<blockquote>
<p>
In the Java programming language, an interface is a reference type, similar to a class, that can contain only constants, method signatures, default methods, static methods, and nested types. Method bodies exist only for default methods and static methods. Interfaces cannot be instantiated—they can only be implemented by classes or extended by other interfaces.
</p>

<p>
&#x2013; <a href="https://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html">https://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html</a>
</p>
</blockquote>

<p>
Java Interface 在设计角度，是一种规范（ Contract ）。其规定了实现该 Interface 的「类」应该具备哪些行为（接口中的方法），即这个类能做些什么。但是！并不规定「类」该如何做。一个滥俗的例子：
</p>


<div class="org-src-container">
<pre class="src src-java"><span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">interface</span> <span style="color: #A8CE93;">Animal</span>{
    <span style="color: #A8CE93;">int</span> <span style="color: #DF8C8C;">age</span>=<span style="color: #7FC1CA; font-weight: bold;">1</span>; <span style="color: #899BA6;">// </span><span style="color: #899BA6;">-&gt; &#32534;&#35793;&#21518;&#20462;&#39280;&#31526;&#20026; public static final</span>
    <span style="color: #A8CE93;">String</span> <span style="color: #DF8C8C;">name</span> = <span style="color: #7FC1CA;">"babalala"</span>;
    <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">eat</span>(); <span style="color: #899BA6;">// </span><span style="color: #899BA6;">-&gt; &#32534;&#35793;&#21518;&#20462;&#39280;&#31526;&#20026; public abstract</span>
    <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">sleep</span>();
}

<span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">class</span> <span style="color: #A8CE93;">monkey</span> <span style="color: #9A93E1;">implements</span> <span style="color: #A8CE93;">Animal</span>{
    <span style="color: #7FC1CA;">@Override</span>
    <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">eat</span>(){
        <span style="color: #899BA6;">// </span><span style="color: #899BA6;">eat banana</span>
    }
    <span style="color: #7FC1CA;">@Override</span>
    <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">sleep</span>(){
        <span style="color: #899BA6;">// </span><span style="color: #899BA6;">sleep on the tree</span>
    }
}
</pre>
</div>

<p>
这个接口规定了，实现了<code>interface Animal</code>的类，必须有<code>eat()</code>， <code>sleep()</code> ，的行为。但是！怎么吃和睡，由实现类来决定。比如，猴子吃香蕉，猫吃鱼。
</p>

<p>
这个例子说明，规范中隐含着对代码行为的抽象。比如将，猫吃，狗吃，大象吃，抽象为动物吃。在这个例子中，动物的概念是抽象的，而猫，狗，大象对应着动物的一种具体形态。<b>接口规范一些特定的行为，而不包含如何进行这些行为，即接口中的方法没有具体的方法实现</b>。抽象在 interface 的语法层面中表现为，interface 会被 <code>abstract</code> 修饰（隐藏的，编译后自动加的）。这意味着 interface 和 <a href="#orgc4b8bfb">lang.java.feat.abstract-class</a> 一样不能被实例化。
</p>

<p>
一致的是，接口中的方法是没有<code>{}</code>的。因为<code>{}</code>表示方法体。这表示什么呢？这意味着，接口中的方法也是抽象的，不包含具体定义。在<b>没有</b> <code>default</code>或 <code>static</code> 修饰的方法，都隐含着 abstract 修饰符，指示着接口实现类必须重写该方法。而对于接口中的变量，默认是<code>static final</code>的，也就是静态，即不可变的，必须在定义时指定变量值。
</p>

<p>
那规范和抽象还能意味着什么？或说怎么理解，接口变量都是常量，接口方法要么具有默认实现（Java 8 后， <code>default</code> 修饰方法，即可编写方法体），要么就是 <code>static</code> 修饰的？
</p>

<p>
<b>规范和抽象还隐含着无状态</b> 。
</p>

<p>
通常一个 class 可以被实例化，所以拥有属于实例自身的状态（实例变量），以及有具体实现的方法。因为接口不定义具体实现，所以其应该和具体的状态无关。这样做会带来什么好处呢？<a href="#org1afa784">lang.java.oop.feat.polymorphism</a>「 <b>多态</b> 」！
</p>

<p>
Java 接口是可以被多实现的。接口在 Java 类型系统中，是一个引用类型。对于实现了接口的具体类（实现意味着定义行为的具体实现），就具备这组行为的具体实现。对于 Animal 接口，Monkey 类和 Cat 类都实现了这个 Animal ，意味着它们遵循着 Animal的规范，具有吃和睡觉的行为。当我编写一个方法，方法参数是 Animal 类型，并在方法中调用 Animal 的 <code>eat()</code> 方法，这会出现什么效果呢？
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#39282;&#20859;&#21592;&#21890;&#20859;&#21160;&#29289;</span>
<span style="color: #9A93E1;">public</span> feed(Animal animal){
    animal.eat();
    <span style="color: #899BA6;">// </span><span style="color: #899BA6;">then animal.sleep(); or do something else</span>
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #A8CE93;">Monkey</span> <span style="color: #DF8C8C;">monkey</span> = <span style="color: #9A93E1;">new</span> <span style="color: #A8CE93;">Monkey</span>();
<span style="color: #A8CE93;">Cat</span> <span style="color: #DF8C8C;">cat</span> = <span style="color: #9A93E1;">new</span> <span style="color: #A8CE93;">Cat</span>();
feed(monkey);
feed(cat);
</pre>
</div>

<p>
Animal 「变态」了！
</p>

<p>
<code>feed(Animal animal)</code> 方法的行为，随着传入的实现类型不同，而发生了改变。相比于为猴子，猫各写一个喂食方法，比如<code>feedCat()</code>, <code>feedMonkey()</code>，一个<code>feed(Animal)</code>实现了对于不同类型却具备相同抽象（即都能做什么）的方法整合，即方法的抽象。在符合一致抽象的情况下，面向抽象编程。
</p>

<p>
在 <code>feed</code> 方法中，相当于针对引用类型 <code>Animal</code> 制定了一套通用的控制逻辑，即喂动物。具体怎么喂，则由调用 feed 方法的使用者决定。面向抽象编程的一个含义是，将代码的执行逻辑推迟，交给调用者决定应该执行什么具体逻辑。这体现了，所谓的开闭原则：「<b>对具体执行逻辑的扩展保持开放，对控制逻辑的修改保持封闭</b>」。也就是说，<code>feed(Animal animal)</code>是一套非具体过程，面向抽象的「控制逻辑」。其对兼容更多种类动物的实现保持开放。比如定义一个<code>class dog implements Animal</code>， <code>feed(Animal animal)</code> 就享受了新的扩展性，而无需更改面向抽象的逻辑。反过来，当需要修改面向抽象的逻辑时，比如动物吃完，去玩，而不是睡觉了，那所有实现了接口 Animal 的类，都可以获得这份改变。从这个例子可以知道，面向抽象编程，通过将代码中不变的逻辑抽取，降低代码的复杂度，并提高了代码的可维护性。
</p>

<p>
可以发现，多态的出现，是为了让不同的代码逻辑从相似的代码中抽离出来，并延迟了计算结果，即当将如何计算交给调用者，而不是耦合于代码之中。延迟计算的层次越高，则代码会越抽象，也就越稳定，越可维护。可以再过分点，将具体调用<code>feed(Animal)</code>能传什么动物，储存为一个<code>HashMap&lt;String, Animal&gt; animalTypeMap</code>，将具体的代码逻辑抽象化成了一个动物名称，根据动物名称选择 feed 应该表现出什么的结果。至于选什么，就交给程序的用户，想看饲养员喂什么动物了。当，动物园想要添加一些新动物的时候，比如狮子。饲养员喂动物的流程无需改变，只需要增加一个狮子实现类<code>class Lion implements Animal</code>，并且在 <code>animalTypeMap</code> 中添加动物类型和 <code>Lion</code> ，就完成了对动物园业务的扩展，而无需改变饲养员喂养动物的大体流程（先吃，后睡，再玩）。再比如，餐馆点单程序，面向抽象的订单编程，而不是对每一道菜编程。可以用一套代码控制点菜的流程，即所有菜品共用的代码，而不是为白切鸡，红烧肉，糖醋里脊分别写一个点菜方法控制点菜的流程。
</p>
</div>
</div>

<div id="outline-container-orgc4b8bfb" class="outline-2">
<h2 id="orgc4b8bfb"><span class="section-number-2">16.</span> lang.java.feat.abstract<sub>class</sub>&#x2013;Mechanism between Class and Interface</h2>
<div class="outline-text-2" id="text-16">
<p>
abstract 修饰符用于修饰类和方法。abstract 表达的语义是： 1 ）修饰类，表示类不能被实例化，需要被继承； 2 ）修饰方法，表示方法需要被实现，即重写。
</p>

<blockquote>
<p>
An abstract class is a class that is declared abstract—it may or may not include abstract methods. Abstract classes cannot be instantiated, but they can be subclassed.
</p>

<p>
An abstract method is a method that is declared without an implementation (without braces, and followed by a semicolon), like this:
</p>

<p>
abstract void moveTo(double deltaX, double deltaY);
</p>

<p>
If a class includes abstract methods, then the class itself must be declared abstract, as in:
</p>

<p>
public abstract class GraphicObject {
   <i>/ declare fields
   /</i> declare nonabstract methods
   abstract void draw();
}
</p>

<p>
When an abstract class is subclassed, the subclass usually provides implementations for all of the abstract methods in its parent class. However, if it does not, then the subclass must also be declared abstract.
</p>

<p>
<a href="https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html">https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html</a>
</p>
</blockquote>

<p>
如果按照 abstract 所表达的语义，相比于<a href="#org7a89ec3">lang.java.feat.interface</a>（Interface 也是默认 abstract 修饰的），为什么需要抽象类呢？
</p>

<p>
可以从是否具有「状态」来理解接口和抽象类的区别。
</p>

<p>
<b>接口的一大特点是「无状态」</b> 。接口内的变量是<code>public static final</code>，不可变的。其不像具体类的实例，可以拥有实例变量，储存实例状态。<b>抽象类可以具有实例状态，并其实例变量可以被子类所共享</b>。另外，抽象类可以部分抽象，包含对实例变量操作的共同方法的默认实现，即子类需要实现抽象类中的 abstract 方法，且可以选择重写抽象类中的默认实现方法，并且这些方法可以做<a href="#org74a66dc">lang.java.feat.access-level-modifiers</a>全范围的权限限制，而接口的方法和变量均为 public。
</p>

<p>
abstract class 作为concrete class和 Interface 的中间地带，即可以定义规范，也可以含有带状态的默认实现。可以发现抽象类和普通类的区别在于：多了 abstract 修饰方法的能力，并且不能被实例化而已。
</p>

<table>


<colgroup>
<col  class="org-center">

<col  class="org-center">

<col  class="org-center">

<col  class="org-center">
</colgroup>
<tbody>
<tr>
<td class="org-center">对比</td>
<td class="org-center">普通类</td>
<td class="org-center">抽象类</td>
<td class="org-center">接口</td>
</tr>

<tr>
<td class="org-center">可见权限范围-变量</td>
<td class="org-center">无限制</td>
<td class="org-center">无限制</td>
<td class="org-center">only <code>public static final</code></td>
</tr>

<tr>
<td class="org-center">可见权限范围-方法</td>
<td class="org-center">无限制</td>
<td class="org-center">无限制</td>
<td class="org-center">only <code>public</code> also <code>abstract</code></td>
</tr>

<tr>
<td class="org-center">abstract 方法</td>
<td class="org-center">X</td>
<td class="org-center">√</td>
<td class="org-center">√</td>
</tr>

<tr>
<td class="org-center">构造方法</td>
<td class="org-center">√</td>
<td class="org-center">构造子类时会调用</td>
<td class="org-center">X</td>
</tr>

<tr>
<td class="org-center">实例方法</td>
<td class="org-center">√</td>
<td class="org-center">√</td>
<td class="org-center">default 修饰（实现类可以重写）</td>
</tr>

<tr>
<td class="org-center">static 方法</td>
<td class="org-center">√</td>
<td class="org-center">√</td>
<td class="org-center">X</td>
</tr>

<tr>
<td class="org-center">static blocks</td>
<td class="org-center">√</td>
<td class="org-center">√</td>
<td class="org-center">X</td>
</tr>
</tbody>
</table>

<p>
应该如何使用abstract class呢？设想一个场景，如果 100 个类需要实现一个相同的接口方法，并且实现是一致的，该怎么办呢？
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">interface</span> <span style="color: #A8CE93;">InterfaceWith100Implementions</span>{
    <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">ImplememtedBy100Class</span>();
}
</pre>
</div>

<p>
从Java 8开始，可以使用 <code>default</code> 关键字定义接口方法的默认实现。如果这 100 个子类想遵循接口定义的规范，并且想共享一些实例变量，并在共有的方法使用这些变量，该怎么办呢？这时候抽象类就派上了用场。
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">abstract</span> <span style="color: #9A93E1;">class</span> <span style="color: #A8CE93;">SharedBy100Class</span> <span style="color: #9A93E1;">implements</span> <span style="color: #A8CE93;">InterfaceWith100Implementions</span>{
    <span style="color: #9A93E1;">private</span> <span style="color: #A8CE93;">int</span> <span style="color: #DF8C8C;">commonInstanceVariable</span>;

    <span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#21487;&#20197;&#26377;&#20004;&#31181;&#23545;&#25509;&#21475;&#26041;&#27861;&#23454;&#29616;&#30340;&#36873;&#25321;</span>
    <span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#20004;&#32773;&#22312;&#20351;&#29992;&#20013;&#19981;&#20849;&#23384;&#65292;&#22240;&#20026;&#26041;&#27861;&#23450;&#20041;&#20914;&#31361;&#65292;&#36825;&#37324;&#20030;&#20010;&#20363;&#23376;&#35828;&#26126;&#12290;</span>
    <span style="color: #899BA6;">// </span><span style="color: #899BA6;">1) &#30041;&#20010;&#23376;&#31867;&#23454;&#29616;</span>
    <span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">abstract</span> <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">ImplememtedBy100Class</span>();

    <span style="color: #899BA6;">// </span><span style="color: #899BA6;">2) &#25552;&#20379;&#40664;&#35748;&#23454;&#29616;</span>
    <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">ImplememtedBy100Class</span>();

    <span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#20351;&#29992;&#23454;&#20363;&#21464;&#37327;&#30340;&#23454;&#20363;&#26041;&#27861; &#20351;&#29992; protected &#20462;&#39280;&#34920;&#31034;&#26041;&#27861;&#30340;&#21487;&#35265;&#33539;&#22260;&#25511;&#21046;&#22312;&#32487;&#25215;&#38142;&#20013;&#12290;</span>
    <span style="color: #9A93E1;">protected</span> <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">useCommonInstanceVariable</span>(){
        commonInstanceVariable = <span style="color: #7FC1CA; font-weight: bold;">1</span>;
        system.out.println(commonInstanceVariable);
    }

}
</pre>
</div>

<p>
在java.util包中，许多集合实现所遵循的模式是，使用 interface 定义规范，并使用abstract class提供部分的默认实现，具体的实现类，既继承了abstract class又通过声明实现规范 interface ，以显化隐式的实现。比如， HashMap 就是一个很好的例子。HashMap 继承了抽象类 AbstractMap 并实现了 Map 接口。
</p>
</div>

<div id="outline-container-org25c7e77" class="outline-3">
<h3 id="org25c7e77"><span class="section-number-3">16.1.</span> abstract-template-pattern</h3>
<div class="outline-text-3" id="text-16-1">
<ul class="org-ul">
<li>含抽象方法：不提供默认实现，希望子类重写</li>
<li>不含抽象方法：不希望被实例化，仅仅是提供一个模板。因为默认实现可以被覆盖，运行时执行实现类的逻辑。</li>
</ul>

<p>
抽象类和模板模式的使用比如 HttpServlet 的 Service 根据请求类型，提供一个处理请求的模板，doGet() 只是提供一个占位，具体实现还是需要被子类来实现的。
</p>

<blockquote>
<p>
父类把能写的逻辑都写完，把不确定的业务代码抽成一个方法，调用它。当子类重写该方法，整个业务代码就活了。这就是模板方法模式
</p>
</blockquote>

<p>
这里使用了模板方法。
<a href="#org74a66dc">lang.java.rule.access-level-modifiers</a> <code>protected</code> 关键字在工具包中定义方法，调用方需要继承该类，才能使用该方法 <a href="#org053d832">lang.java.feat.anonymous-class.access-to-protected-method-in-other-package</a>
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">abstract</span> <span style="color: #9A93E1;">class</span> <span style="color: #A8CE93;">HttpServlet</span> <span style="color: #9A93E1;">extends</span> <span style="color: #A8CE93;">GenericServlet</span> {
<span style="color: #899BA6;">//</span><span style="color: #899BA6;">&#20854;&#20182;&#26041;&#27861;&#19982;&#25104;&#21592;&#21464;&#37327;&#65292;&#30053;...</span>
    service(<span style="color: #A8CE93;">ServletRequest</span> <span style="color: #DF8C8C;">req</span>, ServletReponse res) {
        <span style="color: #A8CE93;">HttpServletRequest</span> <span style="color: #DF8C8C;">request</span> = (<span style="color: #A8CE93;">HttpServletRequest</span>) req;
        <span style="color: #A8CE93;">HttpServletResponse</span> <span style="color: #DF8C8C;">response</span> =(<span style="color: #A8CE93;">HttpServletResponse</span>)res;
        service(request, response);
    }
    <span style="color: #9A93E1;">protected</span> <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">service</span>(<span style="color: #A8CE93;">HttpServletRequest</span> <span style="color: #DF8C8C;">req</span>, <span style="color: #A8CE93;">HttpServletResponse</span> <span style="color: #DF8C8C;">resp</span>) {
        <span style="color: #A8CE93;">String</span> <span style="color: #DF8C8C;">method</span> = req.getMethod();
        <span style="color: #9A93E1;">if</span>(<span style="color: #A8CE93;">METHOD</span> <span style="color: #83AFE5;">GET.equals</span>(<span style="color: #A8CE93;">method</span>)){
            <span style="color: #899BA6;">//</span><span style="color: #899BA6;">&#26412;&#26469;&#19994;&#21153;&#36923;&#36753;&#24212;&#35813;&#30452;&#25509;&#20889;&#22312;&#36825;&#65292;&#20294;&#26159;&#29238;&#31867;&#26080;&#27861;&#30693;&#36947;&#23376;&#31867;&#20855;&#20307;&#19994;&#21153;&#36923;&#36753;</span>
            doGet(req, resp);
        } <span style="color: #9A93E1;">else</span> <span style="color: #9A93E1;">if</span> (...) {
            ...
        } <span style="color: #9A93E1;">else</span> <span style="color: #9A93E1;">if</span> ...
    }
    <span style="color: #9A93E1;">protected</span> <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">doGet</span>(<span style="color: #A8CE93;">HttpServletRequest</span> <span style="color: #DF8C8C;">req</span>, <span style="color: #A8CE93;">HttpServletResponse</span> <span style="color: #DF8C8C;">res</span>) {
        <span style="color: #899BA6;">//</span><span style="color: #899BA6;">&#40664;&#35748;&#23454;&#29616;&#65292;&#21521;&#39029;&#38754;&#36755;&#20986; :405&#65292;http.get method not supported//&#36825;&#31181;&#23454;&#29616;&#26159;&#27809;&#26377;&#24847;&#20041;&#30340;&#65292;&#25152;&#20197;&#23376;&#31867;&#24517;&#39035;&#33267;&#23569;&#37325;&#20889;7&#20010;doxxx0&#20013;&#30340;&#19968;&#20010;&#65292;&#29992;&#20110;&#22788;&#29702;&#29305;&#23450;&#35831;&#27714;</span>
    }
    <span style="color: #899BA6;">//</span><span style="color: #899BA6;">&#20854;&#23427;&#20845;&#20010;doXxx0&#26041;&#27861;...</span>
}
</pre>
</div>

<p>
只需要继承 HttpServlet 实现doGet()，doPost()，请求的处理逻辑， Tomcat 就会处理请求和响应的接收和发送。
</p>
</div>
</div>
<div id="outline-container-orgf759907" class="outline-3">
<h3 id="orgf759907"><span class="section-number-3">16.2.</span> Reference</h3>
<div class="outline-text-3" id="text-16-2">
<ul class="org-ul">
<li><a href="https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html">https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html</a></li>
<li>bravo 1988 (2022) servlet的本质以及如何工作. Available at: <a href="https://www.zhihu.com/question/21416727">https://www.zhihu.com/question/21416727</a> (Accessed: 25 April 2022).</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgddf7935" class="outline-2">
<h2 id="orgddf7935"><span class="section-number-2">17.</span> lang.java.feat.dynamic<sub>proxy</sub>&#x2013;Mechanism to append feature to existed code</h2>
<div class="outline-text-2" id="text-17">
<p>
动态代理的使用场景是：
</p>
<ol class="org-ol">
<li>给一组实现了共同接口的对象，添加额外的功能，其特点是，只需要编写一次代码，将被代理的对象，传入编写好的动态代理函数即可；</li>
<li>Spring AOP，面向切面编程核心是动态创建代理对象继承目标对象，通过目标对象持有代理对象调用目标对象的方法。</li>
</ol>

<p>
理解动态代理的前提：
</p>

<ol class="org-ol">
<li><a href="#org6575cdb">Java 对象（ Object ）</a>；</li>
<li><a href="#org0731022">Java 类的生命周期</a>；</li>
<li><a href="#orgeb75c2b">Java 反射（ Reflection ）</a>；</li>
<li><a href="#org356edf0">面向对象编程</a> 之接口实现多态。</li>
</ol>

<p>
动态代理核心的思想：用接口 T 创建Class&lt;T&gt;对象，即实例化接口返回一个代理对象。通过将被代理对象（后续称为——目标对象）作为参数传入，在代理对象中通过反射执行目标对象的方法，并添加额外的功能。
</p>

<p>
动态代理的具体实现，依靠<code>java.lang.reflect.Proxy</code>类和功能接口<code>java.lang.reflect.InvocationHandler</code>实现。
</p>

<p>
首先得了解反射是如何创建一个对象的实例的：
</p>

<p>
通过 <a href="#orgeb75c2b">Java 反射（ Reflection ）</a> 创建一个对象的流程是：1) 获取描述对象 T 的 Class&lt;T&gt; 对象；2) 通过Class&lt;T&gt;对象获取 T 对象的构造器；3) 使用 <code>newInstance</code> 创建对象 T 的实例。
</p>

<p>
因为接口无法创建实例的，=Proxy= 类可以通过接收*一组接口*和类加载器返回一组<code>Class&lt;T&gt;</code>对象。该<code>Class&lt;T&gt;</code>对象为代理对象添加了一个<code>class T(InvocationHandler.class)</code>的构造方法。则反射实例化代理对象时需要传入一个功能接口 <code>InvocationHandler</code> 并实现 <code>invoke</code> 方法。
</p>

<p>
<code>Invoke(Object proxy, Method method, Object[] args)</code> 就是代理方法，通过在该方法中，创建目标对象，执行目标对象的方法，并添加额外的功能包装，完成动态代理的实现。
</p>

<p>
Proxy 类主要提供两个方法获取接口 <code>T</code> 的 <code>Class&lt;T&gt;</code> 对象：
</p>

<ol class="org-ol">
<li><code>getProxyClass(ClassLoader, Interfaces)</code> 直接返回一个描述对象 <code>T</code> 的 <code>Class&lt;T&gt;</code> 对象；</li>
<li><code>newProxyInstance(ClassLoader, Interfaces, InvocationHandler)=，其包含获取=Class&lt;T&gt;</code>对象以及通过<code>Class&lt;T&gt;</code>实例化代理对象的步骤。</li>
</ol>


<div class="org-src-container">
<pre class="src src-java"><span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">class</span> <span style="color: #A8CE93;">DynamicProxy</span>{
    <span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">static</span> <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">main</span>(<span style="color: #A8CE93;">String</span> <span style="color: #DF8C8C;">args</span>[]) <span style="color: #9A93E1;">throws</span> <span style="color: #A8CE93;">Throwable</span>{
        <span style="color: #A8CE93;">CalculatorImpl</span> <span style="color: #DF8C8C;">target</span> = <span style="color: #9A93E1;">new</span> <span style="color: #A8CE93;">CalculatorImpl</span>();
        <span style="color: #A8CE93;">Calculator</span> <span style="color: #DF8C8C;">calculatorProxy</span> = (<span style="color: #A8CE93;">Calculator</span>) getProxy(target); <span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#22810;&#24577;&#65292;&#29992;&#25509;&#21475;&#25345;&#26377;&#23454;&#29616;&#31867;&#23545;&#35937;&#65292;&#19981;&#31649; target &#26159;&#20160;&#20040;&#23454;&#29616;&#31867;&#37117;&#33021;&#20256;&#20837;&#21040;&#20195;&#29702;&#31867;&#20013;&#65307;</span>
        calculatorProxy.add(<span style="color: #7FC1CA; font-weight: bold;">1</span>, <span style="color: #7FC1CA; font-weight: bold;">2</span>);
        calculatorProxy.subtract(<span style="color: #7FC1CA; font-weight: bold;">2</span>, <span style="color: #7FC1CA; font-weight: bold;">1</span>);
    }

    <span style="color: #9A93E1;">private</span> <span style="color: #9A93E1;">static</span> <span style="color: #A8CE93;">Object</span> <span style="color: #83AFE5;">getProxy</span>(<span style="color: #9A93E1;">final</span> <span style="color: #A8CE93;">Object</span> <span style="color: #DF8C8C;">target</span>) <span style="color: #9A93E1;">throws</span> <span style="color: #A8CE93;">Exception</span>{
        <span style="color: #A8CE93;">Object</span> <span style="color: #DF8C8C;">proxy</span> =
            Porxy.newProxyInstance(target.getClass().getClassLoader(),
                                    target.getClass().getInterfaces(),
                                    (proxy, method, args) -&gt; {
                                        <span style="color: #A8CE93;">print</span> <span style="color: #DF8C8C;">log1</span>;
                                        <span style="color: #A8CE93;">Object</span> <span style="color: #DF8C8C;">result</span> = method.invoke(target, args);
                                        <span style="color: #A8CE93;">print</span> <span style="color: #DF8C8C;">log2</span>;
                                        <span style="color: #9A93E1;">return</span> result;});
        <span style="color: #9A93E1;">return</span> proxy;
    }
</pre>
</div>
</div>
</div>
<div id="outline-container-org8da09fb" class="outline-2">
<h2 id="org8da09fb"><span class="section-number-2">18.</span> lang.java.feat.lambda&#x2013;Syntactic sugar of anonymous class</h2>
<div class="outline-text-2" id="text-18">
<p>
lambda 是<a href="20230726T105636--functional-programming.html#ID-25d86cb3-abb6-4a1f-b4f2-e49e1bf9bae4">functional-programming.concept.higher-order-function</a>的一个特性。
</p>

<p>
这需要从传递函数开始说起。在过程语言中，如C/C++，通过函数指针可以将函数 A 作为参数在函数 B 中传递。在 Java 中，没有方法指针，所以使用接口来传递方法。在C/C++中，作为参数的函数被称为「回调函数」。去他的术语，只需要明白函数或方法在不同的语言中，传递机制是怎样的即可。
</p>

<blockquote>
<p>
The callback function in Java works in the following manner:
</p>

<ol class="org-ol">
<li>Create an interface X having a single method A().</li>
<li>Create a method method1() with A as a method parameter.</li>
<li>Call the A() method inside of the method1().</li>
<li>For calling method1(), we pass the instance of X and override the A().</li>
<li>Use arrow notation as an alternative to keyword news so that the code is clear.</li>
</ol>

<p>
from: <a href="https://www.javatpoint.com/java-callback-function">https://www.javatpoint.com/java-callback-function</a>
</p>
</blockquote>

<p>
Lambda 表达式是一个<code>匿名方法</code>，在 Java 中用于简化传递方法的语法。即在方法中传递「功能接口的实现」。功能接口中的抽象方法，定义了匿名方法的「形参类型」与「返回值」。
</p>

<p>
功能接口可以被理解为方法的规范。
</p>

<p>
在没有 Lambda 表达式前，需要通过使用匿名类的方式传递功能接口，即在参数中创建一个匿名类并且覆写功能接口中的抽象方法：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #899BA6;">// </span><span style="color: #899BA6;">Collections.sort(List list, Comparator&lt;T&gt;)</span>
Collections.sort(<span style="color: #A8CE93;">listOfMovies</span>, <span style="color: #9A93E1;">new</span> <span style="color: #A8CE93;">Comparator</span>&lt;<span style="color: #A8CE93;">Movie</span>&gt;() {
    <span style="color: #7FC1CA;">@Override</span>
    <span style="color: #9A93E1;">public</span> <span style="color: #A8CE93;">int</span> <span style="color: #83AFE5;">compare</span>(<span style="color: #A8CE93;">Movie</span> <span style="color: #DF8C8C;">o1</span>, <span style="color: #A8CE93;">Movie</span> <span style="color: #DF8C8C;">o2</span>) {
    <span style="color: #9A93E1;">return</span> o1.getMovieName().compareTo(o2.getMovieName());
    }
});
</pre>
</div>

<p>
如果使用 Lambda 表达式，则上面的语法可以简化为：
</p>

<div class="org-src-container">
<pre class="src src-java">Collection.sort(<span style="color: #A8CE93;">listOfMovies</span>, (o1, o2) -&gt; o1.getMovieName().compareTo(o2.getMovieName()));
</pre>
</div>

<p>
Lambda 表达式由三部分组成：「参数列表」-&gt; {「表达式」}。
</p>

<p>
在前面提到，Lambda 实质上是一个函数，则函数的参数类型和返回值根据功能接口定义来确定。
</p>

<p>
「参数列表」中的类型，可以省略，因为编译器可以根据功能接口的定义自动推断。‘{}’中的表达式，需要返回特定的类型，如果只有一条语句，可以省略‘{}’。
</p>

<p>
参考：
</p>
<ul class="org-ul">
<li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1305158055100449">LXF-Lambda 基础</a></li>
<li><a href="https://java2blog.com/lambda-expressions-in-java-8/">https://java2blog.com/lambda-expressions-in-java-8/</a></li>
</ul>
</div>

<div id="outline-container-orgb89d467" class="outline-3">
<h3 id="orgb89d467"><span class="section-number-3">18.1.</span> lang.java.feat.lambda.method-qoute</h3>
<div class="outline-text-3" id="text-18-1">
<p>
使用方法引用可以更加简洁地传递功能接口的实现。
</p>

<p>
引用语法： <code>类名::方法名</code>
</p>

<p>
引用的方法类型可以是，1) 静态方法，2) 实例方法，3) 构造方法
</p>

<p>
举例，静态方法：
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">class</span> <span style="color: #A8CE93;">Main</span> {
    <span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">static</span> <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">main</span>(<span style="color: #A8CE93;">String</span>[] <span style="color: #DF8C8C;">args</span>) {
        <span style="color: #A8CE93;">String</span>[] <span style="color: #DF8C8C;">array</span> = <span style="color: #9A93E1;">new</span> <span style="color: #A8CE93;">String</span>[] { <span style="color: #7FC1CA;">"Apple"</span>, <span style="color: #7FC1CA;">"Orange"</span>, <span style="color: #7FC1CA;">"Banana"</span>, <span style="color: #7FC1CA;">"Lemon"</span> };
        Arrays.sort(array, Main::cmp);
        System.out.println(String.join(<span style="color: #7FC1CA;">", "</span>, array));
    }

    <span style="color: #9A93E1;">static</span> <span style="color: #A8CE93;">int</span> <span style="color: #83AFE5;">cmp</span>(<span style="color: #A8CE93;">String</span> <span style="color: #DF8C8C;">s1</span>, <span style="color: #A8CE93;">String</span> <span style="color: #DF8C8C;">s2</span>) {
        <span style="color: #9A93E1;">return</span> s1.compareTo(s2);
    }
}
</pre>
</div>

<p>
构造方法的引用语法为：=类名::new=
</p>

<p>
需要注意的是：<b>方法引用只是功能接口实现的一种方式，传入的方法依然需要满足功能接口所规定的「参数类型」和「返回类型」</b>。
</p>
</div>
</div>

<div id="outline-container-orgf4fd1c6" class="outline-3">
<h3 id="orgf4fd1c6"><span class="section-number-3">18.2.</span> Functional Interface</h3>
<div class="outline-text-3" id="text-18-2">
<p>
功能接口可以理解为函数的容器或包装。通过功能接口包装函数，达到在方法参数传递函数的目的。功能接口可以赋予，函数的惰性求值，即不到函数被使用的一刻都不会被执行。【这个理解是比较到位的，从功能性上考虑功能接口的作用】
</p>

<p>
功能接口是那些只包含「*单个抽象方法*」的接口。这就是说，功能接口除了包含「单个抽象方法」外，还可以包含 <code>default</code> 方法， <code>static</code> 方法和重写来自java.lang.object的方法。
</p>

<p>
一个单方法的功能接口：
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #7FC1CA;">@FunctionalInterface</span>
<span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">interface</span> <span style="color: #A8CE93;">Callable</span>&lt;<span style="color: #A8CE93;">V</span>&gt; {
    <span style="color: #A8CE93;">V</span> <span style="color: #83AFE5;">call</span>() <span style="color: #9A93E1;">throws</span> <span style="color: #A8CE93;">Exception</span>;
}
</pre>
</div>

<p>
一个包含其他方法的功能接口：
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #7FC1CA;">@FunctionalInterface</span>
<span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">interface</span> <span style="color: #A8CE93;">Comparator</span>&lt;<span style="color: #A8CE93;">T</span>&gt; {

    <span style="color: #A8CE93;">int</span> <span style="color: #83AFE5;">compare</span>(<span style="color: #A8CE93;">T</span> <span style="color: #DF8C8C;">o1</span>, <span style="color: #A8CE93;">T</span> <span style="color: #DF8C8C;">o2</span>);

    <span style="color: #A8CE93;">boolean</span> <span style="color: #83AFE5;">equals</span>(<span style="color: #A8CE93;">Object</span> <span style="color: #DF8C8C;">obj</span>);

    <span style="color: #9A93E1;">default</span> <span style="color: #A8CE93;">Comparator</span>&lt;<span style="color: #A8CE93;">T</span>&gt; <span style="color: #83AFE5;">reversed</span>() {
        <span style="color: #9A93E1;">return</span> Collections.reverseOrder(<span style="color: #9A93E1;">this</span>);
    }

    <span style="color: #9A93E1;">default</span> <span style="color: #A8CE93;">Comparator</span>&lt;<span style="color: #A8CE93;">T</span>&gt; <span style="color: #83AFE5;">thenComparing</span>(<span style="color: #A8CE93;">Comparator</span>&lt;? <span style="color: #9A93E1;">super</span> <span style="color: #A8CE93;">T</span>&gt; <span style="color: #DF8C8C;">other</span>) {
        ...
    }
    ...
}

</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org103535f" class="outline-2">
<h2 id="org103535f"><span class="section-number-2">19.</span> brochure.java.feat.optional&#x2013;Return-default-if-object-null</h2>
<div class="outline-text-2" id="text-19">
<p>
在Java 8中，你可以使用`Optional`来处理可能为空的值，并根据情况返回默认值。下面是一个示例，展示了如何使用`Optional`来实现这一功能：
</p>

<div class="org-src-container">
<pre class="src src-java">```java
<span style="color: #9A93E1;">import</span> <span style="color: #7FC1CA;">java</span>.<span style="color: #7FC1CA;">util</span>.<span style="color: #A8CE93;">Optional</span>;

<span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">class</span> <span style="color: #A8CE93;">OptionalExample</span> {
    <span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">static</span> <span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">main</span>(<span style="color: #A8CE93;">String</span>[] <span style="color: #DF8C8C;">args</span>) {
        <span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#21019;&#24314;&#19968;&#20010; Optional &#23545;&#35937;&#65292;&#36825;&#37324;&#20551;&#35774;&#23427;&#21487;&#33021;&#20026;&#31354;</span>
        <span style="color: #A8CE93;">Optional</span>&lt;<span style="color: #A8CE93;">String</span>&gt; <span style="color: #DF8C8C;">optionalValue</span> = Optional.ofNullable(getNullableValue());

        <span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#22914;&#26524;&#20540;&#19981;&#20026;&#31354;&#65292;&#36820;&#22238;&#35813;&#20540;&#65307;&#21542;&#21017;&#36820;&#22238;&#40664;&#35748;&#20540;</span>
        <span style="color: #A8CE93;">String</span> <span style="color: #DF8C8C;">result</span> = optionalValue.orElse(<span style="color: #7FC1CA;">"&#40664;&#35748;&#20540;"</span>);

        System.out.println(<span style="color: #7FC1CA;">"&#32467;&#26524;: "</span> + result);
    }

    <span style="color: #9A93E1;">public</span> <span style="color: #9A93E1;">static</span> <span style="color: #A8CE93;">String</span> <span style="color: #83AFE5;">getNullableValue</span>() {
        <span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#22312;&#23454;&#38469;&#24773;&#20917;&#20013;&#65292;&#36825;&#20010;&#26041;&#27861;&#21487;&#33021;&#36820;&#22238;&#19968;&#20010;&#20540;&#65292;&#25110;&#32773;&#36820;&#22238; null</span>
        <span style="color: #9A93E1;">return</span> <span style="color: #7FC1CA;">"&#23454;&#38469;&#20540;"</span>; <span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#20551;&#35774;&#36825;&#37324;&#26377;&#19968;&#20010;&#23454;&#38469;&#20540;</span>
        <span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#22914;&#26524;&#27809;&#26377;&#23454;&#38469;&#20540;&#65292;&#21487;&#20197;&#36820;&#22238; null&#65292;Optional.ofNullable &#21487;&#20197;&#22788;&#29702; null &#20540;</span>
    }
}
```
</pre>
</div>

<p>
在上述示例中，`getNullableValue()` 方法模拟了一个可能返回值的场景，我们用`Optional.ofNullable`将它包装为`Optional`对象。然后，使用`orElse`方法来获取值，如果值为空，将会返回指定的默认值。
</p>

<p>
如果`optionalValue`包含一个非空值，那么`result`将会是实际值；如果`optionalValue`为空，`result` 将会是指定的默认值。
</p>

<p>
这种方式可以帮助你更加优雅地处理可能为空的情况，并提供一个合适的默认值。
</p>
</div>
</div>
<div id="outline-container-org9c5938e" class="outline-2">
<h2 id="org9c5938e"><span class="section-number-2">20.</span> lang.java.feat.stream.collectors</h2>
<div class="outline-text-2" id="text-20">
<p>
This operation use in <code>.collect()</code> to reduce the stream into a new collection, like <a href="../../main/20230619T105636--qujinja_wms.html#ID-bab0e0d0-934c-4466-bb71-eae1fc03f851">lang.java.data.collection.list</a>, map, set etc.
</p>

<blockquote>
<p>
Implementations of Collector that implement various useful reduction operations, such as accumulating elements into collections, summarizing elements according to various criteria, etc.
The following are examples of using the predefined collectors to perform common mutable reduction tasks:
</p>

<p>
Since 1.8
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-java"> <span style="color: #899BA6;">// </span><span style="color: #899BA6;">Accumulate names into a List</span>
 <span style="color: #A8CE93;">List</span>&lt;<span style="color: #A8CE93;">String</span>&gt; <span style="color: #DF8C8C;">list</span> = people.stream()
     .map(Person::getName)
     .collect(Collectors.toList());

 <span style="color: #899BA6;">// </span><span style="color: #899BA6;">Accumulate names into a TreeSet</span>
 <span style="color: #A8CE93;">Set</span>&lt;<span style="color: #A8CE93;">String</span>&gt; <span style="color: #DF8C8C;">set</span> = people.stream()
     .map(Person::getName)
     .collect(Collectors.toCollection(TreeSet::<span style="color: #9A93E1;">new</span>));

 <span style="color: #899BA6;">// </span><span style="color: #899BA6;">Convert elements to strings and concatenate them, separated by commas</span>
 <span style="color: #A8CE93;">String</span> <span style="color: #DF8C8C;">joined</span> = things.stream()
     .map(Object::toString)
     .collect(Collectors.joining(<span style="color: #7FC1CA;">","</span>));

 <span style="color: #899BA6;">// </span><span style="color: #899BA6;">Compute sum of salaries of employee</span>
 <span style="color: #A8CE93;">int</span> <span style="color: #DF8C8C;">total</span> = employees.stream()
     .collect(Collectors.summingInt(Employee::getSalary));

 <span style="color: #899BA6;">// </span><span style="color: #899BA6;">Group employees by department</span>
 <span style="color: #A8CE93;">Map</span>&lt;<span style="color: #A8CE93;">Department</span>, <span style="color: #A8CE93;">List</span>&lt;<span style="color: #A8CE93;">Employee</span>&gt;&gt; <span style="color: #DF8C8C;">byDept</span> = employees.stream()
     .collect(Collectors.groupingBy(Employee::getDepartment));

 <span style="color: #899BA6;">// </span><span style="color: #899BA6;">Compute sum of salaries by department</span>
 <span style="color: #A8CE93;">Map</span>&lt;<span style="color: #A8CE93;">Department</span>, <span style="color: #A8CE93;">Integer</span>&gt; <span style="color: #DF8C8C;">totalByDept</span> = employees.stream()
     .collect(Collectors.groupingBy(Employee::getDepartment, Collectors.summingInt(Employee::getSalary)));

 <span style="color: #899BA6;">// </span><span style="color: #899BA6;">Partition students into passing and failing</span>
 <span style="color: #A8CE93;">Map</span>&lt;<span style="color: #A8CE93;">Boolean</span>, <span style="color: #A8CE93;">List</span>&lt;<span style="color: #A8CE93;">Student</span>&gt;&gt; <span style="color: #DF8C8C;">passingFailing</span> = students.stream()
     .collect(Collectors.partitioningBy(s -&gt; s.getGrade() &gt;= PASS_THRESHOLD));

</pre>
</div>
</div>

<div id="outline-container-org439f0d5" class="outline-3">
<h3 id="org439f0d5"><span class="section-number-3">20.1.</span> brochure</h3>
<div class="outline-text-3" id="text-20-1">
<ul class="org-ul">
<li><a href="../../main/20230620T105636--ja_wms_notes.html#ID-702175ee-5734-496d-a235-7b9ac5de82a8">lang.java.brochure.stream.list2map</a></li>

<li><a href="../../main/20230620T105636--ja_wms_notes.html#ID-5b30d9af-cf4b-4f1d-99fe-497423a90eec">lang.java.brochure.stream.list2string</a></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgec3b4ea" class="outline-2">
<h2 id="orgec3b4ea"><span class="section-number-2">21.</span> Reference</h2>
<div class="outline-text-2" id="text-21">
<style>.csl-entry{text-indent: -1.5em; margin-left: 1.5em;}</style><div class="csl-bib-body">
</div>
</div>
</div>
<div id="outline-container-orgb4272b3" class="outline-2">
<h2 id="orgb4272b3"><span class="section-number-2">22.</span> Update</h2>
</div>
<div class="taglist"><a href="https://oahnukuw.github.io/tags.html">Tags</a>: <a href="https://oahnukuw.github.io/tag-blog.java.html">blog.java</a> </div>]]></description>
  <category><![CDATA[blog.java]]></category>
  <link>https://oahnukuw.github.io/20240806T182547--java_features_that_i_learned.html</link>
  <guid>https://oahnukuw.github.io/20240806T182547--java_features_that_i_learned.html</guid>
  <pubDate>Tue, 06 Aug 2024 18:25:00 +0800</pubDate>
</item>
<item>
  <title><![CDATA[函数式编程是什么？]]></title>
  <description><![CDATA[
<nav id="table-of-contents" role="doc-toc">
<h2> <a href="javascript:window.scrollTo(0,0)" style="color: black !important;" class="tooltip" title="Go to the top of the page">Ξ </a> </h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org0523d24">1. functional-programming.concept.immutable-data</a></li>
<li><a href="#org6b55f47">2. functional-programming.concept.no-side-effects</a></li>
<li><a href="#org3549178">3. functional-programming.concept.higher-order-function</a></li>
<li><a href="#org59317e3">4. functional-programming.vs.lang.java.object-oriented-programming</a></li>
<li><a href="#org4283a7c">5. References</a></li>
</ul>
</div>
</nav>
<p>
当谈到函数式编程的特点时，两个关键概念是不可变数据（Immutable Data）和无副作用（No Side Effects）。
</p>

<div id="outline-container-org0523d24" class="outline-2">
<h2 id="org0523d24"><span class="section-number-2">1.</span> functional-programming.concept.immutable-data</h2>
<div class="outline-text-2" id="text-1">
<p>
在函数式编程中，数据一旦被创建就不可更改。这意味着，一旦你创建了一个对象，你不能直接修改它的状态，而是通过创建一个新的对象来表达数据的变化。这种不可变性有助于避免并发问题，使得代码更容易推理和测试，并且在多线程环境下更加安全。
</p>

<p>
在 Java 中，String 类就是一个典型的不可变类。一旦你创建了一个字符串对象，它的值就不能被修改。
</p>

<div class="org-src-container">
<pre class="src src-java">
```java
String str = <span style="color: #7FC1CA;">"Hello"</span>;
<span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#19981;&#33021;&#20462;&#25913;&#23383;&#31526;&#20018;&#30340;&#20869;&#23481;&#65292;&#21482;&#33021;&#21019;&#24314;&#19968;&#20010;&#26032;&#30340;&#23383;&#31526;&#20018;&#23545;&#35937;</span>
<span style="color: #A8CE93;">String</span> <span style="color: #DF8C8C;">newStr</span> = str + <span style="color: #7FC1CA;">" World"</span>;
```
</pre>
</div>

<p>
可见functional-programming.java.mapper-insert-invade-immutable-data的例子，实现这一特性。
</p>
</div>
</div>

<div id="outline-container-org6b55f47" class="outline-2">
<h2 id="org6b55f47"><span class="section-number-2">2.</span> functional-programming.concept.no-side-effects</h2>
<div class="outline-text-2" id="text-2">
<p>
函数式编程强调函数的计算过程不应该产生对除了函数返回值以外的其他外部状态的影响。这意味着函数不应该修改任何可变的全局变量、类属性或引起其他的状态变化。函数的计算过程应该是纯粹的，只依赖于输入参数，并始终产生相同的输出结果。
</p>

<p>
在 Java 中，下面是一个例子展示了带有副作用和无副作用的函数：
</p>

<div class="org-src-container">
<pre class="src src-java">
```java
<span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#24102;&#26377;&#21103;&#20316;&#29992;&#30340;&#20989;&#25968;</span>
<span style="color: #A8CE93;">int</span> globalVar = <span style="color: #7FC1CA; font-weight: bold;">0</span>;

<span style="color: #A8CE93;">void</span> <span style="color: #83AFE5;">addToGlobalVar</span>(<span style="color: #A8CE93;">int</span> <span style="color: #DF8C8C;">value</span>) {
    globalVar += value; <span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#20462;&#25913;&#20840;&#23616;&#21464;&#37327;&#65292;&#20135;&#29983;&#21103;&#20316;&#29992;</span>
}

<span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#26080;&#21103;&#20316;&#29992;&#30340;&#20989;&#25968;</span>
<span style="color: #A8CE93;">int</span> <span style="color: #83AFE5;">add</span>(<span style="color: #A8CE93;">int</span> <span style="color: #DF8C8C;">a</span>, <span style="color: #A8CE93;">int</span> <span style="color: #DF8C8C;">b</span>) {
    <span style="color: #9A93E1;">return</span> a + b; <span style="color: #899BA6;">// </span><span style="color: #899BA6;">&#32431;&#31929;&#30340;&#20989;&#25968;&#65292;&#27809;&#26377;&#21103;&#20316;&#29992;</span>
}
```
</pre>
</div>

<p>
在上面的例子中，`addToGlobalVar` 函数修改了全局变量`globalVar`的值，产生了副作用。而`add`函数是一个纯粹的函数，它只依赖于输入参数`a`和 `b`，并返回它们的和，没有产生任何副作用。
</p>

<p>
函数式编程中的不可变数据和无副作用的特点使得代码更容易推理和理解，更容易进行测试和并行处理，也有助于避免一些常见的编程错误。这些特点是函数式编程范式的重要优势。
</p>
</div>
</div>

<div id="outline-container-org3549178" class="outline-2">
<h2 id="org3549178"><span class="section-number-2">3.</span> functional-programming.concept.higher-order-function</h2>
<div class="outline-text-2" id="text-3">
<p>
（Higher-Order Function）是指可以接受一个或多个函数作为参数，并/或返回一个函数作为结果的函数。换句话说，它是将函数作为一等公民对待的编程语言特性。在函数式编程中，高阶函数是一种常见的概念，它允许函数作为数据进行操作，从而实现更加灵活和抽象的编程方式。
</p>

<p>
在支持高阶函数的编程语言中，函数可以像普通数据类型一样被传递、赋值给变量，也可以作为函数的返回值。
</p>

<p>
以下是一个简单的例子来说明高阶函数的概念，使用 Python 的代码示例：
</p>

<div class="org-src-container">
<pre class="src src-java">
```python
# &#23450;&#20041;&#19968;&#20010;&#39640;&#38454;&#20989;&#25968;&#65292;&#25509;&#21463;&#19968;&#20010;&#20989;&#25968;&#20316;&#20026;&#21442;&#25968;
def apply_operation(operation, a, b):
    <span style="color: #9A93E1;">return</span> operation(a, b)

# &#23450;&#20041;&#20004;&#20010;&#31616;&#21333;&#30340;&#25805;&#20316;&#20989;&#25968;
def add(a, b):
    <span style="color: #9A93E1;">return</span> a + b

def multiply(a, b):
    <span style="color: #9A93E1;">return</span> a * b

# &#20351;&#29992;&#39640;&#38454;&#20989;&#25968;&#65292;&#23558;&#25805;&#20316;&#20989;&#25968;&#20316;&#20026;&#21442;&#25968;&#20256;&#36882;
result1 = apply_operation(add, <span style="color: #7FC1CA; font-weight: bold;">2</span>, <span style="color: #7FC1CA; font-weight: bold;">3</span>)       # &#31561;&#21516;&#20110;&#35843;&#29992; add(<span style="color: #7FC1CA; font-weight: bold;">2</span>, <span style="color: #7FC1CA; font-weight: bold;">3</span>)&#65292;&#32467;&#26524;&#20026; <span style="color: #7FC1CA; font-weight: bold;">5</span>
result2 = apply_operation(multiply, <span style="color: #7FC1CA; font-weight: bold;">2</span>, <span style="color: #7FC1CA; font-weight: bold;">3</span>)  # &#31561;&#21516;&#20110;&#35843;&#29992; multiply(<span style="color: #7FC1CA; font-weight: bold;">2</span>, <span style="color: #7FC1CA; font-weight: bold;">3</span>)&#65292;&#32467;&#26524;&#20026; <span style="color: #7FC1CA; font-weight: bold;">6</span>
```
</pre>
</div>

<p>
在这个例子中，`apply<sub>operation</sub>` 就是一个高阶函数。它接受一个函数作为第一个参数`operation`，然后将后面的 `a`和 `b` 参数传递给这个函数，并返回它的结果。
</p>

<p>
高阶函数的优点在于它可以促进代码的重用性和灵活性。通过将函数作为参数传递，我们可以在不修改高阶函数的情况下，轻松地改变其行为。这样的抽象能力在函数式编程中非常重要，允许我们编写更加简洁、灵活和可维护的代码。高阶函数也是许多函数式编程中的常用模式和技巧。
</p>
</div>
</div>

<div id="outline-container-org59317e3" class="outline-2">
<h2 id="org59317e3"><span class="section-number-2">4.</span> functional-programming.vs.<a href="20240806T182547--java_features_that_i_learn.html#ID-e656f383-398e-445b-b095-0456920b69ea">lang.java.object-oriented-programming</a></h2>
<div class="outline-text-2" id="text-4">
<p>
函数式编程可以很好地融合到，面向对象编程中。
</p>

<p>
对于系统开发，如果以功能项作为划分，则按照功能去实现，会导致代码与功能高耦合。当变动功能时，重构难度很大，而面向对象对业务进行抽象，把功能看成若干对象的交互。当功能发生变化时，只需要改变对象的交互方式，而不是对功能进行重构。
</p>

<p>
而函数式编程的<a href="#org0523d24">不可变数据（Immutable Data）</a>以及调用的<a href="#org6b55f47">无副作用（No Side Effects）</a>均能够在对象交互层面提供更高的健壮性。
</p>

<p>
Java 8 引入的 <a href="20240806T182547--java_features_that_i_learn.html#ID-37c13a3f-cff9-4698-9aea-d557b94cbd51">Lambda 表达式（ Java ）</a> 就是一个很好的例子，输入一个 List 可以对其进行各种操作，再按照传入的函数处理返回一个期望的数据结构。
</p>

<blockquote>
<p>
Master the functional programming paradigm so you are able to judiciously apply the lessons learned to other domains. Your object systems (for one) will resonate with referential transparency goodness and be much closer to their functional counterparts than many would have you believe. In fact, some would even assert that the apex of functional programming and object orientation are merely a reflection of each other, a form of computational yin and yang ——By Edward Garson
</p>
</blockquote>

<p>
对于面向对象编程，在拆解业务逻辑的过程中，尽量写不干预入参的办法，在参数处理层面采用命令式的编程范式，在参数处理内部使用函数式编程，划分成一个个处理单元，进而对函数的返回值，进行进一步的处理。
</p>

<p>
对于业务逻辑之外，整体呈现的是面向抽象编程的范式。真正做到从细节到框架上的代码健壮性，更高的可维护性。
</p>
</div>
</div>

<div id="outline-container-org4283a7c" class="outline-2">
<h2 id="org4283a7c"><span class="section-number-2">5.</span> References</h2>
<div class="outline-text-2" id="text-5">
<ul class="org-ul">
<li>ChatGpt-3.5: 函数式编程的特点包括不可变数据、无副作用，可以详细解释下么？给出 java 语言中的例子</li>
<li>Apply Functional Programming Principles · 97 Things Every Programmer Should Know (no date). Available at: <a href="https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_02/">https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_02/</a> (Accessed: 26 July 2023).</li>
</ul>
</div>
</div>
<div class="taglist"><a href="https://oahnukuw.github.io/tags.html">Tags</a>: <a href="https://oahnukuw.github.io/tag-blog.java.html">blog.java</a> </div>]]></description>
  <category><![CDATA[blog.java]]></category>
  <link>https://oahnukuw.github.io/20230726T105636--functional-programming.html</link>
  <guid>https://oahnukuw.github.io/20230726T105636--functional-programming.html</guid>
  <pubDate>Tue, 06 Aug 2024 18:25:00 +0800</pubDate>
</item>
<item>
  <title><![CDATA[刻意练习的关键：心理表征]]></title>
  <description><![CDATA[
<nav id="table-of-contents" role="doc-toc">
<h2> <a href="javascript:window.scrollTo(0,0)" style="color: black !important;" class="tooltip" title="Go to the top of the page">Ξ </a> </h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org4f48805">1. 什么是心理表征</a></li>
<li><a href="#org05fcd09">2. 高手之所以为高手：有效的心理表征</a>
<ul>
<li><a href="#orgbf3939f">2.1. &ldquo;树木&rdquo;：相对的具体与模糊</a></li>
<li><a href="#orgc5b0add">2.2. &ldquo;森林&rdquo;：宏观的心理表征</a></li>
</ul>
</li>
<li><a href="#org1cab46e">3. 心理表征的启发：寻找更好的表征——向高手学习</a></li>
<li><a href="#orgb9defef">4. 刻意练习并不通用</a></li>
<li><a href="#org0fd7d9a">5. 刻意练习的原则</a></li>
<li><a href="#org30ba73d">6. 总结一下</a></li>
</ul>
</div>
</nav>
<p>
这是一篇刻意练习的读书笔记。
</p>

<div id="outline-container-org4f48805" class="outline-2">
<h2 id="org4f48805"><span class="section-number-2">1.</span> 什么是心理表征</h2>
<div class="outline-text-2" id="text-1">
<p>
在《刻意练习》这本书中，其提到一个书中比较关键的概念：「心理表征」。
</p>

<blockquote>
<p>
心理表征是一种与我们大脑正在思考的某个物体、某个观点、某些信息或者其他任何事物相对应的心理结构，或具体或抽象。&#x2013;《刻意练习》
</p>
</blockquote>

<p>
作者举了一些例子来说明：
</p>

<blockquote>
<p>
一个简单的例子是视觉形象。例如，一提到蒙娜丽莎，很多人马上便会在脑海中“看到”那幅著名油画的形象；那个形象就是蒙娜丽莎在他们脑海中的心理表征。
</p>

<p>
有些人的表征比其他人更详尽、更准确，而且，他们还能描述关于背景的细节，比如说，描述画中的蒙娜丽莎在哪里坐着，以及她的发型和眉毛的模样。
</p>

<p>
稍稍复杂一些的心理表征的例子是单词，比如说狗。假设你从来没有听说过狗，也从来没有看到过和它相似的动物。也许你在一个孤岛上生活，那里找不到任何的四足动物，只有鸟类、鱼类和昆虫。当别人第一次向你介绍狗的概念时，那些全都只是孤立的数据，而“狗”这个词，对你来说真的没什么意义；它只是这种与你无关的知识的标签；狗身上长毛，有四条腿，喜欢吃肉，喜欢群居，小狗通常被称为“狗狗”，可以对它们进行训练，诸如此类。不过，通常情况下，随着你花时间和狗一块玩，并且开始了解它们，所有这些信息全都被整合到一个全面的概念之中，这个概念由“狗”这个词来表征。现在，当你听到这个词，不必搜索记忆，便能想起关于狗的各种细节；而且，所有这些信息都可以即时访问。你不仅将“狗”这个词添加到了你的单词库之中，而且也添加到了你的心理表征集之中。
</p>
</blockquote>

<p>
在我的理解中，心理表征是一种事物的认识。当用语言尽可能详细地描述一项事物时，也就是在描述对这项事物的心理表征，即对这个事物的认识。心理表征在刻意练习的语境中，是衡量刻意练习的工具。也就是高手和其他人的区别在于对于某领域的认识或说心理表征不同。比如，国际象棋大师对棋盘模式的识别有其特定的编码模式，使得大师能够记住一般人觉得非常复杂的棋盘。
</p>
</div>
</div>

<div id="outline-container-org05fcd09" class="outline-2">
<h2 id="org05fcd09"><span class="section-number-2">2.</span> 高手之所以为高手：有效的心理表征</h2>
<div class="outline-text-2" id="text-2">
<p>
有效的心理表征是区分高手和其他人的关键。刻意练习也就是为了创建更有效的心理表征。那么何为有效呢？
</p>

<p>
能够提高竞争水平的心理表征，即是有效的心理表征。高手本身是一个相对的词。在竞争中只有赢取了绝大多数人的那位才会被成为高手。对于一个特定目标，能够有效击败其他人的心理表征就是有效的。
</p>

<p>
所以作为一个描述性的概念，心理表征这个词并没有太多意义。而是当理解了高手是怎么做的，怎么思考的，我们便有了学习的参考对象，进而更好地使自己达到一个更高的水平。并且，在训练达到一定量的时候，也会创建有效的心理表征。
</p>

<p>
那么一般意义上的，更好的心理表征有哪些特征呢？「既见树木，又见森林」。
</p>
</div>

<div id="outline-container-orgbf3939f" class="outline-3">
<h3 id="orgbf3939f"><span class="section-number-3">2.1.</span> &ldquo;树木&rdquo;：相对的具体与模糊</h3>
<div class="outline-text-3" id="text-2-1">
<p>
心理表征或认识，是相对具体和相对模糊的。大多数人并未在现场看过「蒙娜丽莎」这幅画，可能更多是从图片中，和他人口中的描述建立了对「蒙娜丽莎」的映像。这样的认识，相比于在现场看过，感受现场的灯光，查看到画框和颜料在灯光下所映出的光晕，会比图片具体得多。图片上的「蒙娜丽莎」相比于现场中的实画要模糊和抽象得多。
</p>

<p>
一个心理表征越有效，意味着其对该事物的理解更加具体，具有更多细节，即看到其他人无法看到的细节。
</p>
</div>
</div>

<div id="outline-container-orgc5b0add" class="outline-3">
<h3 id="orgc5b0add"><span class="section-number-3">2.2.</span> &ldquo;森林&rdquo;：宏观的心理表征</h3>
<div class="outline-text-3" id="text-2-2">
<p>
除了细节之外，有效的心理表征还包括合理的抽象，使其能在宏观的层面上把握一件事物。比如，在阅读和写作中，如果能掌握文章的结构，就能在整体上把握文章的主旨是什么，以及主旨是通过哪几部分展开的。又比如，在编程中，不仅仅能看懂每一行代码的含义，又能在整体上理解这段代码组合的程序是做什么的。或说整个项目的各个模块是如何交互合作的。对于刚开始编程的人来说，理解基本的语法可能就够呛了，也就很难从整体上理解各模块代码的交互了。
</p>
</div>
</div>
</div>

<div id="outline-container-org1cab46e" class="outline-2">
<h2 id="org1cab46e"><span class="section-number-2">3.</span> 心理表征的启发：寻找更好的表征——向高手学习</h2>
<div class="outline-text-2" id="text-3">
<p>
在面对一些陌生的知识时，我们通常无从下手，并且常常感到困难，而裹足不前。在尝试理解这个所谓的「心理表征」后，我发现之所以学习知识是困难的，是因为我们缺少方法为知识建立有效的心理表征。当我们对一项事物描述得越多，越具体，并且在宏观上能够将其和相关的知识建立起联系，并识别它们是如何联系的，我们就可以说我对这一项事物更了解。联系到“费曼学习法”，「如果我不能将其清楚地讲述出来，那么说明我还不够理解它」。其也是在建立有效心理表征的一个过程。
</p>

<p>
如何更有效地提高我们的技能水平呢？——学习高手们是怎么做的。
</p>

<p>
如果想做出一道美味的菜肴，很好的方式是看大厨的烧菜步骤，调味品的用量，观摩大厨掌勺的手法，并知道大概这道菜尝起来的味道是什么样的。这就是大厨对一道菜的具体表征。当我们去模仿这个烧菜的过程，用菜的味道来做尝试的反馈。如果咸了，说明是放盐多了，在下一次尝试中修正。多做几次后便慢慢建立起了和大厨类似的心理表征。相比于开始做这道菜时，便有了长足的进步。以此类推，学习编程，学习画画，学习足球，去看看高手是如何思考和如何做的，模仿他们，是提高技能的开始。
</p>
</div>
</div>

<div id="outline-container-orgb9defef" class="outline-2">
<h2 id="orgb9defef"><span class="section-number-2">4.</span> 刻意练习并不通用</h2>
<div class="outline-text-2" id="text-4">
<p>
在理解了心理表征的基础上，我们能够知道刻意练习是以结果为导向的提高技能。这意味着，刻意练习的技能是有明确的衡量目标的。
</p>

<blockquote>
<p>
简单地讲，我们说刻意练习，因为它与其他类型的有目的的练习在两个重要的方面上存在着差别。
</p>

<p>
首先，它需要一个已经得到合理发展的行业或领域，也就是说，在那一行业或领域之中，最杰出的从业者已达到一定程度的表现水平，使他们与其他刚刚进入该行业或领域的人们明显地区分开来。我们指的这些活动，包括音乐表演、芭蕾舞蹈和其他类型的舞蹈、国际象棋以及许多个人和团体的体育项目，特别是根据打分来评判运动员表现和水平的体育项目，如体操、花样滑冰或跳水等。哪些行业或领域不符合条件？是那些并不存在或者很少存在直接竞争的行业或领域，比如园艺和其他爱好，以及当今职场中的许多工作，如企业经理、教师、电工、工程师、咨询师，等等。在这些行业或领域之中，你可能无法从刻意练习中累积知识，因为它们并没有客观的标准来评价卓越的绩效。
</p>

<p>
其次，刻意练习需要一位能够布置练习作业的导师，以帮助学生提高他的水平。导师必须已经达到一定的水平，并且有一些可以传授给别人的有益的练习方法。
</p>

<p>
有了这个定义，我们可以在有目的的练习（其中，人们想尽一切办法来推动自身的提高）与既有目的、又获得指导的练习之间总结出明显的区别。特别是在刻意练习中，受训者了解表现最杰出者的成就，并且受到后者的指导，同时，他们还理解，这些表现最杰出者在哪些方面表现卓越。刻意练习也是一种有目的的练习，而且知道该朝什么方向发展，以及怎样去达到目标。
</p>
</blockquote>

<p>
这说明刻意练习不太适用于复杂衡量标准的领域。比如编程，咨询和管理岗位等。因为这些岗位不存在硬性的绩效来衡量的优劣程度。但像健身有做组的重量，演奏乐器的音准。这类技能，就有很明确的衡量。
</p>

<p>
虽然刻意练习不一定通用，但是我们依然可以参照一些原则，帮助我们提升技能水平。
</p>
</div>
</div>

<div id="outline-container-org0fd7d9a" class="outline-2">
<h2 id="org0fd7d9a"><span class="section-number-2">5.</span> 刻意练习的原则</h2>
<div class="outline-text-2" id="text-5">
<ul class="org-ul">
<li><p>
为练习制定跳一跳够得着的清晰目标
</p>

<p>
看看做得好的伙计是怎么做的？可能你会发现做得好的人很多，方法也很多，这时候并不需要为此感到过多的犹豫，挑上一两个，尝试看看，是否让你感到技能的提升。如果不能，便换一个，也许是你最感兴趣的。尝试的过程需要耐心。如果足够耐心，在技能提升的同时，很有可能会发展出自己的一套有效的训练方法。目标还需要足够的清晰。如果目标是模糊的，比如健身一小时，很可能就不知道一小时内，干什么。因为&ldquo;健身&rdquo;对于目标来说很模糊。一个更好的清晰定义的目标可以是：「感受背阔肌的发力训练 30 个引体向上」。在我看来，在详细描述目标的过程中，也是在具体化对技能认知的过程。如果能够详细地描述，也说明你清楚你缺乏些什么。这个过程可能会挺费劲，并且很慢。但相比于草率地写下一个目标，然后心不在焉地完成，或是直接忽略，这对自身的评价也会造成不太好的影响。可以参考文章 <a href="20240409T160937--what_is_trust.html#ID-08f1293d-0245-449c-a66f-64d95a9d2300">重新理解信任</a> 里介绍履行自我承诺的重要性。在长期项目中，慢即是快。
</p></li>
<li><p>
专注
</p>

<p>
在定义良好的目标下，需要心无旁骛地专注。如果练习一会，刷刷短视频，那么这样的练习是无效的。
</p></li>
<li><p>
通过目标获得反馈
</p>

<p>
一个很好的反馈来源是，来自导师的反馈。好的导师具有丰富的经验，能够提供有效地反馈。但没有导师的情况下，需要自己记录反馈，并根据反馈调整。比如，虽然编程没有客观的绩效指标，但是通过运行结果，我们能够知道编程的练习是对还是错的，使得我们可以及时调整代码。
</p></li>
</ul>


<p>
通过循环， 1 ）制定清晰的目标； 2 ）行动并获得反馈； 3 ）根据反馈调整练习的目标；即便是没有单一衡量标准的领域，这也不失为一个通用地提升技能法则。
</p>
</div>
</div>

<div id="outline-container-org30ba73d" class="outline-2">
<h2 id="org30ba73d"><span class="section-number-2">6.</span> 总结一下</h2>
<div class="outline-text-2" id="text-6">
<p>
如果要开始学习一项新技能，很好的开始是看看前辈们是怎么做的。然后尝试分析他们成功的原因，并开始模仿。对于自学者来说，有一位导师亲自带领总是最有效率的。但并不是所有人都那么幸运，可以接触。但所幸，我们还有互联网还有各种聊天机器人，可以帮助我们进行刻意练习。虽然这个过程往往更难，对于我们个人的审慎，耐心，机动提出了更高的要求。但我相信，如果我们根据刻意练习的原则尝试并坚持，在一项技能中小有成效之时，我们也可以成为后来者的导师。
</p>
</div>
</div>
<div class="taglist"><a href="https://oahnukuw.github.io/tags.html">Tags</a>: <a href="https://oahnukuw.github.io/tag-blog.psychology.html">blog.psychology</a> </div>]]></description>
  <category><![CDATA[blog.psychology]]></category>
  <link>https://oahnukuw.github.io/20240803T082137--mental_representation_deliberate_pratice.html</link>
  <guid>https://oahnukuw.github.io/20240803T082137--mental_representation_deliberate_pratice.html</guid>
  <pubDate>Sat, 03 Aug 2024 08:21:00 +0800</pubDate>
</item>
<item>
  <title><![CDATA[重新理解信任]]></title>
  <description><![CDATA[
<nav id="table-of-contents" role="doc-toc">
<h2> <a href="javascript:window.scrollTo(0,0)" style="color: black !important;" class="tooltip" title="Go to the top of the page">Ξ </a> </h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org2f1cb6a">1. 为什么理解信任很重要？</a></li>
<li><a href="#org831cab6">2. 什么是信任</a></li>
<li><a href="#org80a67c0">3. 那如何理解不信任呢？</a></li>
<li><a href="#org578d3b8">4. 更值得信任与认知行为疗法</a></li>
</ul>
</div>
</nav>
<p>
过去以为，信任（ Trust ）是一个无需思索的东西。然而，通过《牛津通识读本：信任的博弈》，我对信任有了新的理解，并且对一些如何成为更值得信任的人有了新的认识。
</p>

<div id="outline-container-org2f1cb6a" class="outline-2">
<h2 id="org2f1cb6a"><span class="section-number-2">1.</span> 为什么理解信任很重要？</h2>
<div class="outline-text-2" id="text-1">
<blockquote>
<p>
信任位于一个完整概念网的中心，其周围环绕着可靠性、可预测性、期望、合作与善意等概念。而其反面，则是怀疑、欺瞒、阴谋、背叛和无能。—《牛津通识读本：信任的博弈》
</p>
</blockquote>

<p>
这意味着，如果我们理解信任，我们能够更好地理解与其相关的一系列概念。不仅如此，在我看来，信任与自我成长也是强相关的，当我信任自己的时候，我能够更好地面对生活中的挑战，并建立自己和生活的一致性，减少自我怀疑和焦虑，进而成为一个更好的人。（这里可以和自我效能感挂钩，意图性信任和技能型信任）
</p>

<p>
另外，从上述的描述中，可以知道本文谈论的信任，是关于人的，即信任的对象是人。
</p>
</div>
</div>

<div id="outline-container-org831cab6" class="outline-2">
<h2 id="org831cab6"><span class="section-number-2">2.</span> 什么是信任</h2>
<div class="outline-text-2" id="text-2">
<p>
在《牛津通识读本：信任的博弈》中提出对信任做出区分。一个是技能信任（trust in people&rsquo;s skill），另一个是意图性信任（trust in people&rsquo;s intentions）。
</p>

<p>
这意味着，当我对向我借钱的朋友表示信任时，我即相信他愿意还钱，同时他能够还钱。如果他仅仅有还钱的意愿，那么我对他的信任仅仅是在意图层面上，相信他在有钱后，会还钱给我。但是由于他没有工作，我并不相信他有能力还钱。另一方面，如果他有钱，却说自己口袋空空，他是不值得信任的，因为他背叛了他在借钱时所许下会还钱的承诺。
</p>

<p>
从这个例子中，能看出的是，期望承诺的达成是构成信任的关键。信任更像是一种关系，起始于被信任人许下承诺，而信任人相信承诺将会被达成。信任意味着，对他人履行承诺的期望，不仅仅是相信他人履约的意愿，同时相信其有能力履约。信任他人的同时，也说明他人是值得信任的。
</p>
</div>
</div>

<div id="outline-container-org80a67c0" class="outline-2">
<h2 id="org80a67c0"><span class="section-number-2">3.</span> 那如何理解不信任呢？</h2>
<div class="outline-text-2" id="text-3">
<p>
不信任，是一种道德判断。当我们不信任某人时，就是看不起他们。这是一种道德批评。这意味着，这会断绝了后续合作的可能，比如我不再会借钱给那个因为意图或能力不还钱的朋友了，并附上言而无信的指责。
</p>

<p>
这里给到的启示是。重视我们许下的承诺。当我们在答应他人一件事情时，需要意识到，如果无法完成，会降低值得信任的程度，并面临着不值得信任的批判。哪怕我们有强烈完成承诺的意愿，缺乏达成的能力也会导致不信任的发生。对于成为一个更值得信任的人，需要明晰自身能力的边界，不对自己不能做到的事情轻易许诺。
</p>

<p>
需要注意的是，当某人没有做出承诺，就不涉及「信任与否」的问题。比如，我邀请了朋友聚会，他说因为有事而不能来。这就不涉及信任和不信任的问题。因为，我并不对他是否能来聚会有所期待。我也不会怀疑他是否会出现在聚会中。
</p>

<p>
当对一个人的意图和能力不了解的时候，这仅仅说明你对他缺乏信任，而不是不信任。因为他没有作出任何事情的承诺。
</p>
</div>
</div>

<div id="outline-container-org578d3b8" class="outline-2">
<h2 id="org578d3b8"><span class="section-number-2">4.</span> 更值得信任与认知行为疗法</h2>
<div class="outline-text-2" id="text-4">
<p>
在理解了信任的概念后，尝试思考一个问题：如何成为一个值得信赖的人？
</p>

<p>
在看待值得信赖的问题时，更常见的角度是从他人的角度出发，去评价一个人是否值得信任。如果从自身的角度出发呢？在我看来，要提升他人对自己的信任程度，首要是提升自己对自己的信任。也就是说，首先成为值得是自己信赖的人。
</p>

<p>
<a href="https://en.wikipedia.org/wiki/Cognitive_behavioral_therapy">认知行为疗法（维基百科）</a> ，认为可以通过干预其感觉和行为，改变一个人对自身的不良认知。也就是说，我们当下的认知，是由过去的行为和感觉的持续塑造而成的。
</p>


<figure id="org77685e3">
<img src="static/img/2024-04-15_Cognitive_behavioral_therapy.png" alt="2024-04-15_Cognitive_behavioral_therapy.png" height=400px width=500px>

</figure>

<p>
在跨年的时候，我们通常会许下承诺说：“今年我要看多少本书，我要瘦多少斤，我要赚多少钱”。这就是一种对自己的信任，再具体到在工作生活中我们会制定计划，我们都相信我们会完成这些承诺。但当计划无法完成的时候，我们容易产生挫败的感觉，并认为自己不值得自己的信任。这有可能是因为自己暂时能力的不足，或者我们完全有能力，但是因为偷懒，在能够做的时候，不想做，而不去做。这埋下了一个消极的隐患：降低了自己值得信任评级。
</p>

<p>
持续往复，我们会在核心的认知中，认为自己是一个不值得信任的人。
</p>

<p>
反过来，如果我们合理地制定计划，并重视自己的承诺，通过行动达成自己的期望（或多或少，目标并不总是能完美地达成的，但<b>持续</b>行动，就会有更多自己是可信感觉），周而复始，会积累自己是一个值得信任的程度。渐渐的，我们在认知上，会觉得自己是一个可信之人。
</p>

<p>
所以，要慎重对待自己的承诺，尤其是自己写下的计划。在赢得他人的信赖之前，先让自己相信自己能做好某件事。认真对待，为自己的成长做好积极的循环。履行承诺，更加信任自己。收获更多的自信。
</p>

<p>
在积累自信的过程中，我们也在不断地提升自己的能力，帮助我们成为一个更好的人。
</p>

<p>
对于能力上的暂时缺乏，一方面需要给予自己时间和耐心，通过积极地寻找办法，尽可能地去兑现自己的承诺。另一方面，降低期望值。明白自身能力的边界，制定跳一跳能够着的目标，而不是不切实际地追求过高的目标。
</p>
</div>
</div>
<div class="taglist"><a href="https://oahnukuw.github.io/tags.html">Tags</a>: <a href="https://oahnukuw.github.io/tag-blog.psychology.html">blog.psychology</a> </div>]]></description>
  <category><![CDATA[blog.psychology]]></category>
  <link>https://oahnukuw.github.io/20240409T160937--what_is_trust.html</link>
  <guid>https://oahnukuw.github.io/20240409T160937--what_is_trust.html</guid>
  <pubDate>Tue, 09 Apr 2024 16:09:00 +0800</pubDate>
</item>
<item>
  <title><![CDATA[使自己富有韧性的修行]]></title>
  <description><![CDATA[
<nav id="table-of-contents" role="doc-toc">
<h2> <a href="javascript:window.scrollTo(0,0)" style="color: black !important;" class="tooltip" title="Go to the top of the page">Ξ </a> </h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org09e0d23">1. 引言</a></li>
<li><a href="#orgb8b5da8">2. 不如意的过去</a>
<ul>
<li><a href="#orga70cbf7">2.1. 是什么造就了当下的我们</a></li>
<li><a href="#orgd3e85ec">2.2. 尝试给予过去一个拥抱</a></li>
<li><a href="#org31d454a">2.3. 假笑解忧之假戏成真</a></li>
</ul>
</li>
<li><a href="#orgd9f8c4b">3. 不如意像一只白熊</a></li>
<li><a href="#org9853fdd">4. 情绪急救箱</a></li>
<li><a href="#orgcf2ee41">5. 与情绪共存：&rsquo;NAME&rsquo;</a></li>
<li><a href="#org7286a0d">6. 情绪延展之后：「妥协」抑或「改变」</a></li>
<li><a href="#orgd172b35">7. 结语</a></li>
<li><a href="#orgb6a1b76">8. Update</a></li>
</ul>
</div>
</nav>


<div id="outline-container-org09e0d23" class="outline-2">
<h2 id="org09e0d23"><span class="section-number-2">1.</span> 引言</h2>
<div class="outline-text-2" id="text-1">
<p>
生活不如意，十之八九。这也就是说，生活之中大部分是在不如意中度过的。在这一前提下，「如何更幸福地生活？」，是我一直想探究的问题。「如何与不如意相处」，很大程度上决定着对生活的满意度。如果当我们遇到挫折，便觉得生活一片黑暗，失去对生活的信心，进而陷入消极内耗的情绪泥沼。这样的生活注定是脆弱易折，且不幸福的。所以我想从「如何与不如意相处？」的视角出发，尝试回答「如何更幸福地生活？」。从我们的过去出发，分享心理实验「不要想白熊」，重新认识那看似平常的不如意。通过介绍我的情绪急救实践「 NAME 」，帮助我们和不如意共存。希望能帮助你更从容地面对生活中的不如意，并在这个过程中能够更加了解自己，从而更幸福地生活。
</p>
</div>
</div>
<div id="outline-container-orgb8b5da8" class="outline-2">
<h2 id="orgb8b5da8"><span class="section-number-2">2.</span> 不如意的过去</h2>
<div class="outline-text-2" id="text-2">
<p>
在我的经验中，不如意的一大根源，来自于过去。人们常常会过分地抵抗过去所带来的不如意，进而陷入，而无法脱离，进而产生生活中更多的不顺，被其束缚。与过去和解，是迈入未来更好生活的必要条件。我们需要了解如何与过去相处，哪怕是不如意的过去，也能帮助我们更好地生活。
</p>
</div>

<div id="outline-container-orga70cbf7" class="outline-3">
<h3 id="orga70cbf7"><span class="section-number-3">2.1.</span> 是什么造就了当下的我们</h3>
<div class="outline-text-3" id="text-2-1">
<p>
在我们呱呱落地的伊始，父母是谁，出生地在哪，时代何时，决定了我们生长的环境。这般生长环境，并不像花盆的土，可以更换，而是奠定了人生根基，并贯穿人生的始终。
</p>

<p>
如果我身处正值改革开放的中国，我可能会每天早上蹲在银行门口，吃着油条豆浆，等着冲进银行买股票。如果我是处于二十世纪七十年代中的美国黑人，我可能每天跟着马丁路德金上街游行，闲时吃吃薯条和炸鸡。如果我是一个印度人，我每天可能会吃吃咖喱，做做瑜伽，沐浴恒河。很可惜，我并不能一命多用去体验时空中的无数可能，体味各色生活。<b>生活的时空境遇，决定了我们生命的大体方向，过去的自己和过去的时空境遇造就了当下的我们</b>。
</p>

<p>
<b>这份当下，不为我们所转移。</b>
</p>

<p>
在我的观察中，人们会因为「我没有出生在一个富裕的家庭」而感到郁闷；或因为「我没有毕业于一流大学」而在社会上抬不起头；或因为过去决策没有产生理想的结果而懊悔（大学专业选错啦，炒股加一百倍的杠杆被平仓啦，结婚的对象出轨啦，当初房子那么便宜的时候为什么没买呢）。他们会对自身的当下，感到不满，甚至陷入消极之中无法自拔，进而破罐子破摔，即躺平或摆烂。「人生开局太烂，我不玩了」成为大多数人入世的心态。可是，我们未来生活的困苦是否会因躺平或摆烂而变得更加顺意呢？
</p>

<p>
<b>过去已然过去，我们，无法改变。</b>
</p>

<p>
可能过去，给予我们不错的物质生活，或让一场大火夺去了我们所有。顺意的过去，我们都很乐于接纳。然而，对于不如意的过去，否认它，抵抗它，并不会让其减少半分。它，就在那。
</p>
</div>
</div>

<div id="outline-container-orgd3e85ec" class="outline-3">
<h3 id="orgd3e85ec"><span class="section-number-3">2.2.</span> 尝试给予过去一个拥抱</h3>
<div class="outline-text-3" id="text-2-2">
<p>
为什么不接纳过去呢？承认过去那些不如意的存在，与之共处。和那个因过去而受伤的自己，说一声，「没有关系」。
</p>

<p>
否认过去，会阻碍我们创造「未来时那份更好的当下」。随着时间的推移，当下，会成为，未来时的过去。如果持续否认，那么这份对过去的不如意会伴随我们，进入一个又一个未来时的当下。这像是佛教中的万劫不复的地狱，在过去之中一渡又一渡。
</p>

<p>
当我们尝试给过去的自己一个拥抱，接纳其存在，并尝试在其基础上打造一个更符合自身期待的未来，去问，「我能够做些什么让当下的境况变得更好呢」？辅以行动。渐渐，神奇的事情发生了。我们的视角从过去中得到脱离，转而专注未来，「我会拥有一个何般境遇的当下」？
</p>

<p>
在这里我还想分享一个有效的心理暗示：「我接受过去给我带来的当下，即便我并不喜欢这个结果。同时，我愿意为此而承担相应的责任，因为我爱过去的自己。我愿意为此积极思考，寻求办法，帮助我在未来做的更好」。每当一些事情的结果，不如我所愿，我都会和自己说这段话，转而使自己接纳既定的结果，并根据反馈改进自身的行为模式，争取下一次做得更好。
</p>
</div>
</div>

<div id="outline-container-org31d454a" class="outline-3">
<h3 id="org31d454a"><span class="section-number-3">2.3.</span> 假笑解忧之假戏成真</h3>
<div class="outline-text-3" id="text-2-3">
<p>
除了和痛苦的过去和解，飘浮于脑海的想法，杂乱无章，尤其是那些令人感到尴尬的瞬间。在夜深人静的时候，常常不经意地蹦出自己的脑海中。可能是表白被拒绝的尴尬经历，或是当众出丑总想挽回或补救。对付这些不堪，我有一个妙招，就是「笑迎之」。
</p>

<p>
<b>嘴角上扬，保持十秒</b> 。就那么简单。
</p>

<p>
每当我尝试给予这些尴尬一刻一个微笑，会感到一种积极的心理暗示。一是，这是过去发生的事情，不管结果如何，这些都已经是过去；二是，笑让我觉得这并没有什么大不了的。除了尴尬，还有正在面对苦恼时，不妨假笑一下，你会知道这种奇妙的感觉的。
</p>

<p>
不管是拥抱或是假笑，都是接纳过去的一种方式。之所以接纳才得以解脱，是因为基于一个好玩的心理实验：不要想白熊。
</p>
</div>
</div>
</div>

<div id="outline-container-orgd9f8c4b" class="outline-2">
<h2 id="orgd9f8c4b"><span class="section-number-2">3.</span> 不如意像一只白熊</h2>
<div class="outline-text-2" id="text-3">
<p>
不要想白熊<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>这个内心观察，最早出自陀思妥耶夫斯基的笔下。
</p>

<blockquote>
<p>
&ldquo;Try to pose for yourself this task: not to think of a polar bear, and you will see that the cursed thing will come to mind every minute.&rdquo; &#x2013;Fyodor Dostoevsky
</p>
</blockquote>

<p>
这所揭示的是，刻意压制想法会没有效的。
</p>

<blockquote>
<p>
刻意抑制某些想法时，实际上会使这些想法更容易浮出水面。 一个例子是，当某人积极地试图不去想一只白熊时，他实际上更有可能想象一只白熊。
</p>
</blockquote>

<p>
心理学家Daniel Wegner通过实验证明了陀思妥耶夫斯基所观察到的现象是正确的。
</p>

<p>
当然，我们自己试一下，对自己讲不要想白熊，但白熊会萦绕在脑海中。（补充一下，之所以选择白熊做实验是因为白熊在生活中不常出现，可以排除一些实验干扰。）
</p>

<p>
我们的过去，尤其是那些不堪回首的过去，就如同白熊一样。当我们压制这些不堪，它们愈是涌上心头。这也是为什么接纳过去的原因。同样，生活中的各式各样的事件，也会像让人纠结的过去一样，产生各种不如意的情绪，郁闷，悲伤，愤怒。这些‘白熊’往往来势汹汹，陷入它们的同时，往往不自知。待它们消退后，才缓过神，懊悔冲动下决定。暴饮暴食啦，说出伤害他人的话啦，狂买一堆东西啦。
</p>

<p>
我们应该如何应对这些不如意呢？
</p>
</div>
</div>

<div id="outline-container-org9853fdd" class="outline-2">
<h2 id="org9853fdd"><span class="section-number-2">4.</span> 情绪急救箱</h2>
<div class="outline-text-2" id="text-4">
<p>
在生活中，有些不如意是外界刺激的。比如，面对一些生活中让人受伤的事件。
</p>

<ul class="org-ul">
<li>刚和对象分手啦</li>
<li>工作被同事刁难啦</li>
<li>和家人吵架啦</li>
<li>又交不出房租啦</li>
<li>。。。</li>
</ul>

<p>
有一些不如意呢，是从内在自发的
</p>

<ul class="org-ul">
<li>我不想再拖延了</li>
<li>我觉得我太胖了</li>
<li>我觉得我一点点小事都做不好</li>
<li>我觉得。。。</li>
</ul>


<p>
不管是自发或外界刺激，这些不如意总会萦绕心头。当我们愈是不想怎样怎样，也就愈会怎样怎样。还记得「不要想白熊」吗？
</p>

<p>
就我的经验而言，在这些不如意的事件中，我往往会处于局限的状态，不仅在精神上，还在身体上。感觉严重的时候，我开始含胸驼背，呼吸不顺畅，甚至感觉到，血液在不断缩小的血管里艰难穿行，肠子在蜷缩。注意力聚焦在这种不知名的感受上，却意识不到发生了什么，一种被环境激起的本能反应，陷入，久久不能自拔。
</p>

<p>
面对这样的情况我们能怎么办呢？
</p>

<p>
Guy Winch，提出了情绪急救箱的概念<sup><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink">2</a></sup>。在《Emotional First Aid》的前言中，提到
</p>

<blockquote>
<p>
Ask a ten-year-old what you should do if you catch a cold and the child would immediately recommend getting into bed and drinking chicken soup. Ask what you should do if you get a cut on your knee and the child would advocate cleaning it (or using antibacterial ointment) and bandaging it. Children also know that if you break a bone in your leg you need to get a cast on it so it mends correctly. If you then asked why these steps were necessary they would tell you that treating such injuries helps them heal and prevents them from getting worse, that colds can turn into pneumonia, that cuts can become infected, and that if broken bones heal incorrectly you’ll have trouble walking once the cast comes off. We teach our children how to take care of their bodies from a very young age and they usually learn such lessons well.
</p>

<p>
But ask an adult what you should do to ease the sharp pain of rejection, the devastating ache of loneliness, or the bitter disappointment of failure and the person would know little about how to treat these common psychological injuries. Ask what you should do to recover from low self-esteem or loss and trauma and adults would be equally challenged. Ask how you might deal with intrusive ruminations or nagging guilt and you are likely to be met with sheepish looks, feel shuffling, and a pointed effort to change the subject.
</p>
</blockquote>

<p>
对于一个十岁的小孩而言，大人们早已将身体损伤后应该如何修复的方法教给了他们。感冒风寒了要喝热水，引言里提到要喝鸡汤。手被划开口子了，应该上碘伏消毒，然后贴个创可贴。但是，对于大人来说，我们却少有知道，当被拒绝了，心里感觉很受伤应该怎么办？当自己觉得自己很难看，很自卑的时候，又应该怎么办？
</p>

<p>
在Guy Winch的 <a href="https://www.youtube.com/watch?v=F2hc2FLOdhI">TED Talk</a> 中，其提到一个女生，在约会失败的情景，是独自去酒吧，将自己灌醉，并数落自己难看，没有魅力。在Guy Winch看来，这等同于，在正在流血的伤口上，拿刀再将口子划大一些（让血流得更猛烈一些吧：）。用利器继续对伤口进行伤害，这很难在一个成年人里面发生。但是，对于隐形的，看不见的心理创伤，我们却常常，一遍又一遍地将伤口撕裂，扩大，伤害得更深。这也是为什么，我们需要学习情绪急救的原因。我们需要学会，在内心流血的时候，为她包扎，好好呵护她，帮助自己更快地复原。
</p>

<p>
在《Emotional First Aid》中，Guy Winch 将需要急救的常见心理伤口分为了：拒绝，孤独，失去和创伤，罪恶感，郁郁寡欢地沉思（ Rumination ），失败，低自尊。并且，给予了相应的处理方案。对于Guy Winch的方法，我就不一一介绍了，感兴趣的伙伴，可以去读读原书。接下来我想着重分享的实践，是我觉得屡试不爽的，也就是我的情绪急救箱。
</p>
</div>
</div>

<div id="outline-container-orgcf2ee41" class="outline-2">
<h2 id="orgcf2ee41"><span class="section-number-2">5.</span> 与情绪共存：&rsquo;NAME&rsquo;</h2>
<div class="outline-text-2" id="text-5">
<p>
这个方法框架是从一篇文章中学来的，然后在实践的基础上再改进得到的一个最佳实践。&rsquo;NAME&rsquo; 分别指的是， Notice ，Acknowledge，Make a space， Expand 。
</p>

<p>
很推荐去看看原文<sup><a id="fnr.3" class="footref" href="#fn.3" role="doc-backlink">3</a></sup>，写得很好。
</p>

<p>
这个方法的核心是，<b>接纳和延展</b>。这里的接纳并不是普通的接纳，而是在抽离的视角下接纳。我会将自己内心分成两个人。一个较为强大，理智，富有同情心。另一个，比较淘气，容易情绪化，敏感，较为脆弱。每次应激的，你也可以猜到，是那个较为敏感，淘气的那位吧。他就是一个小孩。当与应激的自己相处，可以通过唤醒内心更强大的自己，来帮助那个脆弱，无助的自己获得一种情绪的延展。接下来的实践，最好在没有人打扰的环境下，找个安静可以独处的地方，再加上一些想象力，来尝试一下吧。
</p>

<ol class="org-ol">
<li><p>
Notice：notice your feelings
</p>

<p>
关注自身的情绪，你当下的感受是什么？不带着评价性的眼光，尝试深呼吸，只是尝试察觉，察觉你的感受，不管你认为自身的感觉是好亦或坏，只是感觉你的感觉。
</p></li>

<li><p>
Acknowledge: label it
</p>

<p>
为你的感觉贴上标签，不是指好或坏的标签，而是描述这是什么感觉。是愤怒，亦或沮丧，还是无法面对问题的无奈，还是那种对于问题感觉无能为力的焦虑，不必觉得他们是坏的东西，只是给他们分一个类，你只是自身感觉的经历者，你并不是这些情感。
</p>

<p>
还有一种方式，可以用颜色描述自己的情感。比如，「我现在的心情是灰色的，我感到很郁闷」。「我现在的心情是大红色的，我感到很生气」。通过这种分类和识别，会是自己认识到，当下的自己处于什么状态。
</p>

<p>
当然，你可以用自己的语言，怎么描述是不重要的，而是描述这个过程本身。
</p></li>

<li><p>
Make a space: accept it 给情绪创造点空间
</p>

<p>
尝试与你的感觉做朋友。拉开你身边的椅子，请那位被情绪填满的那个小孩你一起就坐。尝试承认这些情绪的存在，给这个看起来很委屈的小孩一个大大的拥抱（在现实中，将双手环抱自己的双肩，感受一下，被自己拥抱的感觉）。尝试温柔地抚摸下他的头，和他说一声，「我知道你现在很难受，很难过，没关系的」。
</p></li>

<li><p>
Expand: 将情绪向世界延展
</p>

<p>
在你的脑海之外，你还拥有些什么呢? 现在，尝试看看你的周围，或在街上走走，是有哪些你没有注意到的呢？窗外和煦的阳光？柔风将树影吹得婆娑？漫步的人们？也可以伸个懒腰，用手掌向外画个圆。尝试扩展你的体验，不仅仅体验你的情绪，还有情绪之外的自然，广阔世界。此时你会发现，你可以更加镇定地面对生活中的不如意了。
</p></li>
</ol>


<p>
在这番尝试下来，也许你会发现，你已经走出了那个局限的视野，获得更多视角的抽离，并且知道刚刚陷入的情绪并没有什么大不了的。
</p>

<p>
牙刷可以保持的口腔健康，但前提是得养成刷牙的习惯。同样，上述最佳实践是需要持续练习的。在我初期的实践过程中，我发现，每做一次练习会将难受减缓一些。在熟练了该方法后，会感受到自己对抗不如意情绪的韧性增强了很多。相比于一开始，原本只需要做三次练习才能缓解的情绪，到现在只需要一次练习就搞定了。
</p>
</div>
</div>

<div id="outline-container-org7286a0d" class="outline-2">
<h2 id="org7286a0d"><span class="section-number-2">6.</span> 情绪延展之后：「妥协」抑或「改变」</h2>
<div class="outline-text-2" id="text-6">
<p>
读到这里，可能有伙伴会问，「解决了情绪，我并没有解决实际的问题呀。下次遇到问题，我又有情绪了，即便这个能暂时处理好我的情绪，但我生活会因此改变了什么吗」？
</p>

<p>
嘿嘿嘿，解决情绪是解决问题的前提。引起情绪的问题千千万，这个我暂时没有万能的解药。
</p>

<p>
不如意，实质上是自身期望与现实情况有落差。与情绪共处的关键，除了是接纳期望与当下现实不符的事实。在延展情绪和认清现状后，我们一般有两个选择。
</p>

<ol class="org-ol">
<li><p>
尝试降低期望，向现状贴和
</p>

<p>
对于这种情况，并无需做些什么。也就是人们常说的「知足常乐」。
</p></li>

<li><p>
改变现状，使其向期望靠近
</p>

<p>
这个要求会比前者高些。但常常面对想改变，却无从下手。我实践过比较好的方式是，尝试去问自己：「我能够做些什么让当下的境况变得更好呢」？（在上文如何接纳过去也有提到）这句话的关键，是「更好」。改变现状，是有程度的。不知道伙伴们有没有发现，我们通常会默认将这个程度变成「最好」。这会使得我们改变现状的难度陡然上升。然而，「更好」会让我们更容易开始行动，并取得进一步成果。
</p>

<p>
很多时候，我们内心是知道怎么做的，只是我们的情绪会将其屏蔽掉。尝试去问「我能够做些什么让当下的境况变得更好？」会重新让解决问题的答案浮出水面，进而采取一些行动，改善现状。当然，改变现状是一门艺术，是另外一个话题了，后面可以单独写一篇，分享一些心得。
</p></li>
</ol>


<p>
想让自己变得更加坚韧，仅仅靠情绪救急是远远不够的。不管是和过去的自己和解，还是和生活中的不如意和解，都并非一日之功。这需要持续的练习。
</p>
</div>
</div>

<div id="outline-container-orgd172b35" class="outline-2">
<h2 id="orgd172b35"><span class="section-number-2">7.</span> 结语</h2>
<div class="outline-text-2" id="text-7">
<p>
对于生活中的不如意，我还想分享一句话，「除死之外，无大事」。很多时候，我在面对那些看似艰难的挑战，或不顺心的事件，到最后都不过是纸老虎罢了。使障碍，变成‘老虎’的，是我们自己潜在默认的夸大。如果我们能够认识到，「除死之外，无大事」，我们能收获的，是一颗更坚韧的内心，与更多面对生活的勇气。
</p>

<p>
最后，回到文章开头的问题，「如何更幸福的生活？」。既然是更加，就说明幸福是一个渐进的过程。我尝试给出的答案是「从学会和不如意相处开始」。
</p>

<p>
很感谢你能看到这里。希望这篇文章对你有所帮助。如需转载，请注明出处。
</p>
</div>
</div>

<div id="outline-container-orgb6a1b76" class="outline-2">
<h2 id="orgb6a1b76"><span class="section-number-2">8.</span> Update</h2>
<div class="outline-text-2" id="text-8">
<ul class="org-ul">
<li>Note taken on <span class="timestamp-wrapper"><span class="timestamp">[2024-02-29 Thu 22:50]</span></span>
<ul class="org-ul">
<li>更新引言的引导句，增加可读性。运用「自上而下写作法」，点明文章的基础组成</li>
<li>新增结语</li>
</ul></li>
</ul>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Lea Winerman, “Supressing the ’white Bears’,” <i>Https://Www.Apa.Org</i>, October 2011, 44, <a href="https://www.apa.org/monitor/2011/10/unwanted-thoughts">https://www.apa.org/monitor/2011/10/unwanted-thoughts</a>.</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Guy Winch, <i>Emotional First Aid: Healing Rejection, Guilt, Failure, and Other Everyday Hurts</i> (Plume; Reprint edition (July 29, 2014), 2014), <a href="https://www.amazon.com/Emotional-First-Aid-Rejection-Everyday/dp/0142181072/">https://www.amazon.com/Emotional-First-Aid-Rejection-Everyday/dp/0142181072/</a>.</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3" role="doc-backlink">3</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Eric Barker, “This Is How To Be Resilient: 4 Secrets To Grit When Life Gets Hard” (Barking Up The Wrong Tree, November 25, 2019), <a href="https://bakadesuyo.com/2019/11/resilient-2/">https://bakadesuyo.com/2019/11/resilient-2/</a>.</p></div></div>


</div>
</div><div class="taglist"><a href="https://oahnukuw.github.io/tags.html">Tags</a>: <a href="https://oahnukuw.github.io/tag-blog.psychology.html">blog.psychology</a> </div>]]></description>
  <category><![CDATA[blog.psychology]]></category>
  <link>https://oahnukuw.github.io/20240105T165503--how_to_be_full_of_resilience.html</link>
  <guid>https://oahnukuw.github.io/20240105T165503--how_to_be_full_of_resilience.html</guid>
  <pubDate>Tue, 13 Feb 2024 16:55:00 +0800</pubDate>
</item>
</channel>
</rss>
